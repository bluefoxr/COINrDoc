# Data Input

## Introduction

Where possible COINr functions can be used as standalone functions, typically on data frames of indicator data, for operations such as normalisation, imputation and so on.

The full functionality of COINr is however harnessed by assembling the indicator data, and the structure of the index, into a "COIN Object" (catchier name pending). The COIN object is a structured list, which neatly stores the various data sets, parameters, analyses and methodological decisions in one place. There are various reasons for doing this:

1. It simplifies operations because functions know where data and parameters are. Therefore, COINr operations typically follow a syntax of the form `COINobj <- COINr_function(COINobj, <methodological settings>)`, updating the COIN object with new results and data sets generated by the function. This avoids having to repeatedly specify indicator names, structure, etc, as separate arguments.
2. It keeps things organised and avoids a workspace of dozens of variables.
3. It keeps a record of methodological decisions - this allows results to be easily regenerated following "what if" experiments, such as removing or changing indicators etc (see Section on adjustments and reruns TO ADD).

The logic of doing this will become clearer as you build your index. If you only want to use the COINr functions on data frames, you can probably skip this chapter.

## The three inputs

To build a COIN object, three ingredients (data frames) are needed to begin with. In short, they are the indicator data, the indicator metadata, and the aggregation metadata. Here, each will be explained separately. Inputting the data in the first place is where you will do most of the work, because you have to get your data in a format that COINr understands. But once you have got your data assembled, COINr should do most of the hard work, so hang in there!

### Indicator data

The indicator data is a data frame which, shockingly, specifies the data for the indicators. However, it can do more than that, and also some rules have to be followed. The easiest way to explain is to start with an example.

```{r, eval=F}
library(COINr)
head(ASEMIndData)
```

COINr comes prepackaged with some example data - here we are looking at indicator data from the [ASEM Sustainable Connectivity Portal](https://composite-indicators.jrc.ec.europa.eu/asem-sustainable-connectivity/), which has an indicator data set covering 51 Asian and European countries.

The first thing to notice is that each row is an observation (here, a country), and each column is a variable (mostly indicators, but also other things). Look at the structure of the data frame, working from left to right:

* `UnitName` [**required**] gives the name of each unit. Here, units are countries, so these are the names of each country.
* `UnitCode` [**required**] is a unique code assigned to each unit (country). This is very important, and is the main "reference" inside COINr for units. If your units are countries, I recommend using [ISO Alpha-3 codes](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3), because these are recognised by COINr for generating maps. It also makes data processing generally easier.
* `Group_*` [optional] Any column name that starts with `Group_` is recognised as a group column rather than an indicator. You don't have to have any groups, but some COINr functions support specific operations on groups (e.g. imputation within group, and future updates plan to expand this capacity). You can have as many group columns as you want.
* `Year` [optional] gives the reference year of the data. This allows you to have multiple years of data, for example, you can have a value for a given country for 2018, and another value for the same country for 2019, and so on. Like groups, this feature is not yet fully developed in COINr.
* `Den_*`[optional] Any column names that begin with `Den_*` are recognised as *denominators*, i.e. indicators that are used to scale other indicators.
* Any remaining columns that do not use the names in this list are recognised as indicators.

You will notice that all column (variable/indicator) names use short codes. This is to keep things concise in tables, rough plots etc. The full names of indicators, and other details, are also specified in the indicator metadata table - see the next section.

Some important rules and tips to keep in mind are:

* The following columns are *required*. All other columns are optional:
  - UnitCode
  - UnitName
  - At least one indicator column
* Columns don't have to be in any particular order, columns are identified by names rather than positions.
* You can have as many indicators and units as you like.
* Indicator codes and unit codes must have unique names. You can't use the same code twice otherwise bad things will happen.
* Avoid any accented characters or basically any characters outside of English - this can sometimes cause trouble with encoding.
* Column names are case-sensitive. Most things in COINr are built to have a degree of flexibility where possible, but *column names need to be written exactly as they appear here for COINr to recognise them*.,

### Indicator metadata

The second data frame you need to input specifies the *metadata* of each indicator. This serves two purposes: first, to give details about each indicator, such as its name, its units and so on; and second, to specify the structure of the index. Here's what this looks like, for our example ASEM data set:

```{r, eval=F}
head(ASEMIndMeta)
```

Notice that now, the table is flipped on its side (transposed), and each row is an indicator, and the columns specify other things. This is to keep the data in a "tidy" format. Let's go through the columns one by one.

* `IndName` [**required**] This is the full name of the indicator, which will be used in display plots.
* `IndCode`[**required**] A reference code for each indicator. These *must be the same codes as specified in the indicator metadata*. The codes must also be unique.
* `Direction` [**required**] The "direction" of each indicator - this takes values of either 1 or -1 for each indicator. A value of 1 means that higher values of the indicator correspond to higher values of the index, whereas -1 means the opposite.
* `IndWeight` [**required**] The initial weights assigned to each indicator. Weights are relative and do not need to sum to one, so you can simply put all 1s here if you don't know what else to put (the values can be adjusted later).
* `Denominator` [**required**??] These should be the indicator codes of one of the denominator variables for each indicator to be denominated. E.g. here "Den_Pop" specifies that the indicator should be denominated by the "Den_Pop" indicators (population, in this case). For any indicators that do not need denominating, just set `NA`. Denominators can also be specified later, so if you want you can leave this column out.
* `IndUnit` [**optional**] The units of the indicator. This helps for keeping track of what the numbers actually mean, and can be used in plots.
* `Agg*` [**required**] Any column name that begins with `Agg` is recognised as a column specifying the aggregation group, and therefore the structure of the index. Aggregation columns should be in the order of the aggregation, but otherwise can have arbitrary names.

Let's look at the aggregation columns in a bit more detail. Each column represents a separate aggregation level, so in the ASEM example here we have three aggregation levels - the pillars, the two sub-indexes, and the overall index. The entry of each column specifies which group each indicator falls in. So, the first column `Agg1` specifies the pillar of each indicator. Again, each aggregation group (pillar, sub-index or index) is referenced by a unique code.

The next column `Agg2`, gives the sub-index that the indicator belongs to. There is a bit of redundancy here, because obviously indicators in the same pillar must also belong to the same sub-index. Finally, `Agg3` specifies that all indicators belong to the index.

You can have as many `Agg` columns as you like, and the names don't have to be `Agg1` etc, but could be e.g. `Agg_Pillar`, `Agg_SubIndex`, etc. However, they *must* begin with `Agg`, otherwise COINr will not recognise them. And they *must* appear in the order of the aggregation, i.e. lowest level of aggregation first, then working upwards.

### Aggregation metadata

The final data input is the aggregation metadata, which is also the simplest. Here's our example for the ASEM data set:

```{r, eval=F}
head(ASEMAggMeta)
```

This data frame simply consists of three columns for each aggregation level:

* `*Code` [**required**] The aggregation group codes. This column must end with "Code", and the codes must match the codes in the corresponding column in the indicator metadata aggregation columns.
* `*Name` [**required**] The aggregation group names. This column must end with "Name".
* `*Weight` [**required**] The aggregation group weights. This column must end with "Weight". Again, these weights can be changed later on.

Columns must appear in the order of the aggregation groups.

## Putting everything together

Having got all your data in the correct format, you can finally build it into a COIN object. From here, things start to get a bit easier. The function to build the COIN object is called `coin_assemble()`. This function takes the three data frames mentioned and converts them into a so-called *COIN Object*, which is a hierarchical list that is structured in a way that is recognised by all COINr functions. Let's run `coin_assemble()` using the built-in data sets to show how it works.

```{r, eval=F}
ASEM <- coin_assemble(IndData = ASEMIndData, IndMeta = ASEMIndMeta, AggMeta = ASEMAggMeta)
```

The three inputs here are as follows:

* `IndData` which is the indicator data
* `IndMeta` which is the indicator metadata
* `AggMeta` which is the aggregation metadata

And this outputs a "COIN Object" which you can name as you want (here we have called it "ASEM"). There are two further arguments to `coin_assemble()` which are not used here, and they are:

* `include` - this is a character vector of indicator codes (i.e. codes that are found in `IndData$IndCode`) which specifies which indicators to include out of the `IndData` and `IndMeta` inputs. By default, all indicators are included, but this gives the option to only include certain indicators, if for example, you have several alternative data sources.
* `exclude`- this an analogous character vector of indicator codes, but specifying which indicators to *exclude*, if any. Again, by default, nothing is excluded. This may be easier to specify when creating a subset of indicators.

The structure of the list is as follows. First, it is divided into five main sub-lists, which I am going to call "folders":

1. `Input` is the input data, and has the following entries:
    (a) `IndData` The indicator data, *after* any exclusion of indicators
    (b) `IndMeta` The indicator metadata, *after* any exclusion of indicators
    (c) `AggMeta` The aggregation metadata, *after* any exclusion of indicators
    (d) `Original` A list containing the original, unaltered inputs to `coin_assemble()`
2. `Data` is where the indicator data sets are stored. As you go through the construction, this will populated with more data sets, e.g. imputed data, treated data, aggregated data, and so on. On first assembly you will only see `Raw` present here.
3. `Parameters` stores some useful parameters that are used by COINr functions, and may be of general interest, such as the indicator codes, unit codes, weights, and so on.
4. `Analysis` is where analysis of the indicator data will be stored, including missing data analysis, indicator summary statistics, principal component analysis and so on.
5. `Method` keeps a record of the methodological decisions made when constructing the composite indicator, for example the normalisation method and parameters, data treatment specifications, and so on. Apart from keeping a record of the construction, this also allows the entire results to be regenerated using the information stored in the COIN Object, this will be explained better in Chapter XXX.

The logic of the COIN object is that COINr functions can take all the data and parameters that they need from it, and you only have to specify some particular parameters of the function. Then, outputs, such as new data sets, are returned back to the COIN object, which is added to and expanded as the analysis progresses.

Apart from building the COIN Object, `coin_assemble()` does a few other things:

* It checks that indicator codes are consistent between indicator data and indicator metadata
* It checks that required columns, such as indicator codes, are presenr
* It returns some basic information about the data that was input, such as the number of indicators, the number of units, the number of aggregation levels and the groups in each level. This is done so you can check what you have entered, and that it agrees with your expectations.

## Moving on

Now that you have a COIN Object, you can start using all the other functions in COINr to their full potential. Most functions will still work on standalone data frames, so you don't *need* to work with COIN objects if you prefer not to.
