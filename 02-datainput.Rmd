# Data Input

## Introduction

Where possible COINr functions can be used as standalone functions, typically on data frames of indicator data, for operations such as normalisation, imputation and so on.

The full functionality of COINr is however harnessed by assembling the indicator data, and the structure of the index, into a "COIN Object" (catchier name pending). The COIN object is a structured list, which neatly stores the various data sets, parameters, analyses and methodological decisions in one place. There are various reasons for doing this:

1. It simplifies operations because functions know where data and parameters are. Therefore, COINr operations typically follow a syntax of the form `COINobj <- COINr_function(COINobj, <methodological settings>)`, updating the COIN object with new results and data sets generated by the function. This avoids having to repeatedly specify indicator names, structure, etc, as separate arguments.
2. It keeps things organised and avoids a workspace of dozens of variables.
3. It keeps a record of methodological decisions - this allows results to be easily regenerated following "what if" experiments, such as removing or changing indicators etc (see Section on adjustments and reruns TO ADD).

The logic of doing this will become clearer as you build your index. If you only want to use the COINr functions on data frames, you can probably skip this chapter.

## The three inputs

To build a COIN object, three ingredients (data frames) are needed to begin with. In short, they are the indicator data, the indicator metadata, and the aggregation metadata. Here, each will be explained separately. Inputting the data in the first place is where you will do most of the work, because you have to get your data in a format that COINr understands. But once you have got your data assembled, COINr should do most of the hard work, so hang in there!

### Indicator data

The indicator data is a data frame which, shockingly, specifies the data for the indicators. However, it can do more than that, and also some rules have to be followed. The easiest way to explain is to start with an example.

```{r, eval=F}
library(COINr)
head(ASEMIndData)
```

COINr comes prepackaged with some example data - here we are looking at indicator data from the [ASEM Sustainable Connectivity Portal](https://composite-indicators.jrc.ec.europa.eu/asem-sustainable-connectivity/), which has an indicator data set covering 51 Asian and European countries.

The first thing to notice is that each row is an observation (here, a country), and each column is a variable (mostly indicators, but also other things). Look at the structure of the data frame, working from left to right:

* `UnitName` [REQUIRED] gives the name of each unit. Here, units are countries, so these are the names of each country.
* `UnitCode` [REQUIRED] is a unique code assigned to each unit (country). This is very important, and is the main "reference" inside COINr for units. If your units are countries, I recommend using [ISO Alpha-3 codes](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3), because these are recognised by COINr for generating maps. It also makes data processing generally easier.
* `Group_*` [OPTIONAL] Any column name that starts with `Group_` is recognised as a group column rather than an indicator. You don't have to have any groups, but some COINr functions support specific operations on groups (e.g. imputation within group, and future updates plan to expand this capacity). You can have as many group columns as you want.
* `Year` [OPTIONAL] gives the reference year of the data. This allows you to have multiple years of data, for example, you can have a value for a given country for 2018, and another value for the same country for 2019, and so on. Like groups, this feature is not yet fully developed in COINr.
* `Den_*`[OPTIONAL] Any column names that begin with `Den_*` are recognised as *denominators*, i.e. indicators that are used to scale other indicators.
* Any remaining columns that do not use the names in this list are recognised as indicators.

You will notice that all column (variable/indicator) names use short codes. This is to keep things concise in tables, rough plots etc. The full names of indicators, and other details, are also specified in the indicator metadata table - see the next section.

Some important rules and tips to keep in mind are:

* The following columns are *required*. All other columns are optional:
  - UnitCode
  - UnitName
  - At least one indicator column
* Columns don't have to be in any particular order, columns are identified by names rather than positions.
* You can have as many indicators and units as you like.
* Indicator codes and unit codes must have unique names. You can't use the same code twice otherwise bad things will happen.
* Avoid any accented characters or basically any characters outside of English - this can sometimes cause trouble with encoding.

### Indicator metadata

The second data frame you need to input specifies the *metadata* of each indicator. This serves two purposes: first, to give details about each indicator, such as its name, its units and so on; and second, to specify the structure of the index. Here's what this looks like, for our example ASEM data set:

```{r, eval=F}
head(ASEMIndMeta)
```

Notice that now, the table is flipped on its side (transposed), and each row is an indicator, and the columns specify other things. Let's go through them one by one.

* `IndName` [REQUIRED]
* `IndCode`[REQUIRED]
* `Direction` [REQUIRED]
* `IndWeight` [REQUIRED??]
* `Denominator` [REQUIRED??]
* `IndUnit` [OPTIONAL - TO ADD]
* `Agg*`


The main starting point in COINr is to read in your data. To assemble a composite indicator, COINr needs three different inputs (data frames):

1. Raw indicator data (containing values of indicators for each unit)
2. Indicator metadata
3. Aggregation metadata
