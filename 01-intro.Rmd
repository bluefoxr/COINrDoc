# Introduction

The `COINr` package is a comprehensive development and analysis environment for composite indicators and scoreboards, featuring a range of tools for building, visualising and analysing.

This vignette is a work in progress and will be expanded as the COINr project progresses.

## How to use COINr

There are two main ways to use COINr. The first is to use the functions as standalone tools for your own specific use. For example, `coin_normalise.R` will take a data frame as an input, and normalise the columns according to the options specified in its input, outputting another data frame.

The second way is to work inside what I'll call the 'COINrverse' (with tongue firmly in cheek). What this means is that all operations are performed on a single object, the "COIN object", which stores all data, all analysis, parameters, and methodological choices made along the way.

The COINrverse approach enables the full feature set of COINr, because some functions only work on COIN objects - for example, exporting all results to Excel in one command, or running an uncertainty/sensitivity analysis. Indeed, COINr is built mainly for COINrverse use, but functions have been written with the flexibility to also accommodate independent use where possible.

More details on how the COINrverse works can be found in XXX.

## Suggested workflows

E.g. quick construction

Analysis, audit

Comparisons

## A map of COINr

Showing all the functions and the types (e.g. construction, visualisation, analysis, import/export)

## Terminology

Let's clearly define a few terms first to avoid confusion later on.

+ An *indicator* is a variable which has an observed value for each unit. Indicators might be things like life expectancy, CO2 emissions, number of tertiary graduates, and so on.

+ A *unit* is one of the entities that you are comparing using indicators. Often, units are countries, but they could also be regions, universities, individuals or even competing policy options (the latter is the realm of multicriteria decision analysis).

Together, indicators and units form the main input data frame for COINr (units as rows, and indicators as columns).

## Tips for using COINr

### Missing data

It's very important to understand the difference between missing data and zeros. A zero means that you know that the value of the indicator is zero, whereas missing data (in R this is denoted as `NA`) means you don't know what the value is at all.

When aggregating indicators, this difference becomes particularly important. If a data point is missing, it is often excluded from the aggregation, which effectively means reassigning it with the mean (or similar) value of the indicators in the same group. If you impute the data, missing values could be assigned with mean or median indicator values, for example. Clearly, these values will be very different from zeros.

This point is made here, because data may sometimes come with missing values denoted as zeros, or with zeros denoted as missing values. Ensure that these are checked carefully before proceeding with construction.

### Ordering

Currently, COINr is somewhat dependent on the order of the units. Although you can input your data in any order you like (as long as you follow the rules in [Data Input]), in some cases the order does matter. For example, if you want to denominate your data by a separate data frame of indicators (not in the COIN), you will have to make sure that the units (rows) correspond to the same order of rows as your indicator data.

In future updates this dependence on order should be removed, because it is a possible source of errors. For now though, just keep ordering in mind.

It's worth mentioning that the row order never changes in the `.$Data` folder. However, if you screen units using a minimum data requirement (e.g. using `datacheck()`), then the number of units can change. This should also be kept in mind.

### Syntax

Where possible, COINr functions use a common syntax to keep things simple. For example:

* `dset` always refers to the name of the data set that is found in `.$Data`. For example, `dset = "Normalised"` will return `.$Data$Normalised`. The only exception is `dset = "Denominators"`, which returns `.$Input$Denominators`. The argument `dset` is used in many COINr functions because they have to know which data set to operate on.
* More to be added here.

