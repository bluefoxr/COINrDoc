# Foundations

This chapter aims to explain some important principles about how COINr works, as well as giving an overview of the package and suggested workflows. If you want to immediately get to COINr functions without any further ado, skip this chapter for now. However if you want to understand COINr better, this might be worth reading.

## How to use COINr

There are two main ways to use COINr. The first is to use the functions as standalone tools for your own specific use. For example, `coin_normalise.R` will take a data frame as an input, and normalise the columns according to the options specified in its input, outputting another data frame.

The second way is to work inside what I'll call the 'COINrverse' (with tongue firmly in cheek). What this means is that all operations are performed on a single object, the "COIN object", which stores all data, all analysis, parameters, and methodological choices made along the way.

The COINrverse approach enables the full feature set of COINr, because some functions only work on COIN objects - for example, exporting all results to Excel in one command, or running an uncertainty/sensitivity analysis. Indeed, COINr is built mainly for COINrverse use, but functions have been written with the flexibility to also accommodate independent use where possible.

More details on how the COINrverse works can be found in XXX.

## Suggested workflows

E.g. quick construction

Analysis, audit

Comparisons

## A map of COINr

COINr consists of many functions that do a number of different types of operations. Here is a summary.

### Construction

The following functions are the main functions for building a composite indicator in COINr.

Function            Description                                 
------------------  ---------------------------------------------
`assemble()`        Assembles indicator data/metadata into a COIN
`checkData()`       Data availability check and unit screening
`denominate()`      Denominate (divide) indicators by other indicators
`impute()`          Impute missing data using various methods
`treat()`           Treat outliers with Winsorisation and transformations
`normalise()`       Normalise data using various methods
`aggregate()`       Aggregate indicators into hierarchical levels, up to index
`regen()`           Regenerates COIN results using specifications stored in `.$Method`

### Visualisation

These functions are for visualising data.

Function            Description                                 
------------------  ---------------------------------------------
`iplotBar()`        Interactive bar chart for any indicator
`iplotIndDist()`    Interactive indicator distribution plots for a single indicator
`iplotIndDist2()`   Interactive indicator distribution plots for two indicators simultaneously
`iplotMap()`        Interactive choropleth map for any indicator (only works for countries)
`plotCorr()`        Interactive correlation heatmap between any levels of the index
`plotframework()`   Interactive sunburst plot visualising the indicator framework
`plotIndDist()`     Static plot of distributions for indicators and groups of indicators

### Analysis

The following functions analyse indicator data.

Function            Description                                 
------------------  ---------------------------------------------
`cPCA()`            Principle component analysis on a specified data set and subset of indicators. Returns PCA weights.
`effectiveWeight()` Calculates the effective weights of each element in the indicator hierarchy.
`getStats()`        Get table of indicator statistics for any data set
`weightOpt()`       Weight optimisation according to a pre-specified vector of "importances"


### Interactive apps

These are interactive apps, built using Shiny, which allow fast interactive exploration and adjustments.

Function            Description                                 
------------------  ---------------------------------------------
`indDash()`         Indicator visualisation (distribution) dashboard for one or two indicators
`rew8r()`           Interactively re-weight indicators and check updated results and correlations

### Import/export

Functions to import and export data and results to and from COINr and R.

Function            Description                                 
------------------  ---------------------------------------------
`COINToolIn()`      Import indicator data and metadata from COIN Tool
`coin_2Excel()`     Write data, analysis and results from a COIN to Excel

### Other functions

These are other functions that may be of interest, but do not neatly fit in the previous categories. Many of them are called from the other functions listed above, but may still be useful on their own.

Function            Description                                 
------------------  ---------------------------------------------
`BoxCox()`          Box Cox transformation on a vector of data
`build_ASEM()`      Build ASEM (example) composite indicator in one command
`coin_win()`        Winsorise one column of data according to skew/kurtosis thresholds
`copeland()`        Aggregates a data frame into a single column using the Copeland method.
`geoMean()`         Weighted geometric mean of a vector
`getIn()`           Useful function for subsetting indicator data. See [Helper functions].
`harMean()`         Weighted harmonic mean of a vector
`loggish()`         Log-type transformation, of various types, for a vector
`names2Codes()`     Given a character vector of long names (probably with spaces), generates short codes.
`outrankMatrix()`   Outranking matrix based on a data frame of indicator data and corresponding weights
`roundDF()`         Round down a data frame (i.e. for presentation)


### Data

COINr comes with some example data embedded into the package.

Function            Description                                 
------------------  ---------------------------------------------
`ASEMIndData`       ASEM (example) indicator data as input for `assemble()`
`ASEMIndMeta`       ASEM (example) indicator metadata as input for `assemble()`
`ASEMAggMeta`       ASEM (example) aggregate metadata as input for `assemble()`
`WorldDenoms`       National denomination data (GDP, population, etc) worldwide

### Finally

There are also a number functions which are mainly for internal use, and are not listed here.

## Terminology

Let's clearly define a few terms first to avoid confusion later on.

+ An *indicator* is a variable which has an observed value for each unit. Indicators might be things like life expectancy, CO2 emissions, number of tertiary graduates, and so on.

+ A *unit* is one of the entities that you are comparing using indicators. Often, units are countries, but they could also be regions, universities, individuals or even competing policy options (the latter is the realm of multicriteria decision analysis).

Together, indicators and units form the main input data frame for COINr (units as rows, and indicators as columns).

## Levels

COINr frequently refers to "aggregation levels" or equivalently just "levels". Composite indicators are built in a hierarchical structure, such that indicators are aggregated to e.g. sub-pillars, sub-pillars are then aggregated to pillars, and so on up the final index. COINr can handle any number of these "aggregation levels".

Some functions also take the aggregation level as one of their arguments. The convention used by COINr is that the first level (Level 1) is the indicator level, i.e. the columns of data input in `IndData`. Level 2 is aggregated scores resulting from aggregating indicators, Level 3 is the aggregated scores resulting from aggregating the scores in Level 2, and so on.

In the ASEM example, therefore, the levels are defined as follows:

* Level 1 = Indicators
* Level 2 = Pillars
* Level 3 = Sub-indexes
* Level 4 = Index

This means that the ASEM Index has four levels.

## Tips for using COINr

### Missing data

It's very important to understand the difference between missing data and zeros. A zero means that you know that the value of the indicator is zero, whereas missing data (in R this is denoted as `NA`) means you don't know what the value is at all.

When aggregating indicators, this difference becomes particularly important. If a data point is missing, it is often excluded from the aggregation, which effectively means reassigning it with the mean (or similar) value of the indicators in the same group. If you impute the data, missing values could be assigned with mean or median indicator values, for example. Clearly, these values will be very different from zeros.

This point is made here, because data may sometimes come with missing values denoted as zeros, or with zeros denoted as missing values. Ensure that these are checked carefully before proceeding with construction.

### Ordering

Currently, COINr is somewhat dependent on the order of the units. Although you can input your data in any order you like (as long as you follow the rules in [Data Input]), in some cases the order does matter. For example, if you want to denominate your data by a separate data frame of indicators (not in the COIN), you will have to make sure that the units (rows) correspond to the same order of rows as your indicator data.

In future updates this dependence on order should be removed, because it is a possible source of errors. For now though, just keep ordering in mind.

It's worth mentioning that the row order never changes in the `.$Data` folder. However, if you screen units using a minimum data requirement (e.g. using `datacheck()`), then the number of units can change. This should also be kept in mind.

### Syntax

Where possible, COINr functions use a common syntax to keep things simple. For example:

* `dset` always refers to the name of the data set that is found in `.$Data`. For example, `dset = "Normalised"` will return `.$Data$Normalised`. The only exception is `dset = "Denominators"`, which returns `.$Input$Denominators`. The argument `dset` is used in many COINr functions because they have to know which data set to operate on.
* More to be added here.

### Plotting

COINr includes a number of plotting functions which return various types of plots. These are all either based on the ggplot2 or plotly packages. Think of COINr plots as "starting points" rather than finished plots. While I have tried to make the plots useful and even visually appealing, much more could be done to improve them and to fit particular uses and contexts.

Luckily, because of the way that plotly and ggplot2 work, plots generated by COINr can easily be modified by assigning them to an object and then modifying the object. Generally this would look like this:

```{r modifyPlotGeneric, eval=F}
# generate a plot, but assign to variable "plt"
plt <- COINr_plot_function(COIN, plot_options)

# alter plt
plt <- plt + alter_plot_function(options)

# view the plot
plt
```

The `alter_plot_function` could be any of the very many layout and geometry functions from ggplot2, for example. This means you can change colours, axis labels, point styles, titles and many other things.

In summary, with COINr you may choose to either:

* Generate plots with COINr functions and be content with them as they are
* Generate plots with COINr functions and tweak them to your tastes using the approach shown above
* Make your own plots
