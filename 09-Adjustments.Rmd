# Adjustments and comparisons

It's fairly common to make adjustments to the index, perhaps in terms of alternative data sets, indicators, methodological decisions, and so on. COINr allows you to (a) make fast adjustments, and (b) to compare alternative versions of the index relatively easily.

## Regeneration

One of the key advantages of working within the COINrverse is that (nearly) all the methodology that is applied when building a composite indicator (COIN) is stored automatically in a folder of the COIN called `.$Method`. To see what this looks like:

```{r MethodFolder}
# load COINr if not loaded
library(COINr)

# build example COIN
ASEM <- build_ASEM()

# look in ASEM$Method folder in R Studio...
```

```{r echo=F, fig.align = 'center', out.width = "60%", fig.cap = "Method folder in ASEM example"}
knitr::include_graphics("images/method_folder.png")
```

The easiest way to view it is by looking in the viewer of R Studio as in the screenshot above. Essentially, the `.$Method` folder has one entry for each COINr function that was used to build the COIN, and inside each of these folders are the arguments to the function that were input. Notice that the names inside `.$Method$Denomination` correspond exactly to arguments to `denominate()`, for example.

Every time a COINr "construction function" is run, the inputs to the function are automatically recorded inside the COIN. Construction functions are any of the following seven:

Function            Description                                 
------------------  ---------------------------------------------
`assemble()`        Assembles indicator data/metadata into a COIN
`checkData()`       Data availability check and unit screening
`denominate()`      Denominate (divide) indicators by other indicators
`impute()`          Impute missing data using various methods
`treat()`           Treat outliers with Winsorisation and transformations
`normalise()`       Normalise data using various methods
`aggregate()`       Aggregate indicators into hierarchical levels, up to index

These are the core functions that are used to build a composite indicator, from assembling from the original data, up to aggregation.

One reason to do this is simply to have a record of what you did to arrive at the results. However, this is not the main reason (and in fact, it would be anyway good practice to make your own record by creating a script or markdown doc which records the steps). The real advantage is that results can be automatically regenerated with a handy function called `regen()`.

To regenerate the results, simply run e.g.:

```{r RegenSame}
ASEM2 <- regen(ASEM)
```

The `regen()` function reruns all functions that are recorded in the `.$Method` folder *in the order they appear in the folder*. In this example, it runs, in order, `assemble()`, `denominate()`, `impute()`, `treat()`, `normalise()`and `aggregate()`. This replicates exactly the results. But what is the point of that? Well, it means that we can make changes to the index, generally by altering parameters in the `.$Method` folder, and then rerun everything very quickly with a single command. This will be demonstrated in the following section. After that, we will also see how to compare between alternative versions of the index.

Before that, there is one extra feature of `regen()` which is worth mentioning. The `regen()` function only runs the seven construction functions as listed above. These functions are very flexible and should encompass most needs for constructing a composite indicator. But what happens if you want to build in an extra operation, or operations, that are outside of these seven functions?

It is possible to also include "custom" chunks of code inside the COIN. Custom chunks should be written manually using the `quote()` function, to a special folder `.$Method$Custom`. These chunks can be any type of code, but the important thing is to also know *when* to run the code, i.e. at what point in the construction process.

More specifically, custom code chunks are written as a named list. The **name** of the item in the list specifies *when* to perform the operation. For example, "AfterTreatment" means to perform this immediately after the treatment step. Other options are e.g. "AfterNormalisation" or "AfterScreening" -- in general it should be "After" followed by a name of one of the existing folders in the `.$Method` folder.

The corresponding **value** in the list should be an operation which *must* be enclosed in the `quote()` function. Clearly, the list can feature multiple operations at different points in construction.

This is slightly complicated, but can be clarified a bit with an example. Let's imagine that after Winsorisation, we would like to "reset" one of the Winsorised points to its original value. This is currently not possible inside the `treat()` function so has to be done manually. But we would like this operation to be kept when we regenerate the index with variations in methodology (e.g. trying different aggregation functions, weights, etc.).

We create a list with one operation: resetting the point after the treatment step.

```{r}
# Create list. NOTE the use of the quote() function!
custlist = list(AfterTreatment = quote(ASEM$Data$Treated$Bord[ASEM$Data$Treated$UnitCode=="BEL"] <- ASEM2$Data$Imputed$Bord[ASEM$Data$Imputed$UnitCode=="BEL"]))

# Add the list to the $Method$Custom folder
ASEM2$Method$Custom <- custlist
```

Specifically, we have replaced the Winsorised value of Belgium, for the "Bord" indicator, with its imputed value (i.e. the value it had before it was treated).

Now, when we regenerate the COIN using `regen()`, it will insert this extra line of code immediately after the treatment step.

Using custom code may seem a bit confusing but it adds an extra layer of flexibility. It is however intended for small snippets of custom code, rather than large blocks of custom operations. If you are doing a lot of operations outside COINr, it may be better to do this in your own dedicated script or function, rather than trying to encode absolutely everything inside the COIN.

## Adjustments

Let us now explore how the COIN can be adjusted and regenerated. This will (hopefully) clarify why regenerating is a useful thing.

The general steps for adjustments are:

1. Copy the object
2. Adjust the methodology by editing the `.$Method` folder and/or the underlying data
3. Regenerate the results
4. Compare alternatives

The last point is dealt with in the following section. For now, let's see some examples of changing methodology.

First of all, let's consider an alternative index where we decide to remove one of the indicators. In fact, COINr has a short-cut function for this, because to remove/add an indicator, it entails changing both the indicator data and the metadata.

## Comparisons
