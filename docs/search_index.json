[["index.html", "COINr: An R Package for Composite Indicator Development and Analysis Chapter 1 Overview 1.1 Installation 1.2 Whats it for? 1.3 Quick-start guide", " COINr: An R Package for Composite Indicator Development and Analysis William Becker 2021-02-25 Chapter 1 Overview This documentation describes in detail the COINr package, which is an open source R package for developing and analysing composite indicators. In fact, this is slightly more than technical documentation, and also gives some tips on composite indicator development along the way. COINr is currently still under development, therefore the package itself, and this documentation, are a work in progress but are being continually updated. You can find the latest version of COINr at its GitHub repo, and also the source code for this documentation here. 1.1 Installation Although COINr is under development, but a limited pre-beta version can be installed via Github. First, install the devtools package if you dont already have it, then run: devtools::install_github(&quot;bluefoxr/COINr&quot;) This should directly install the package from Github, without any other steps. You may be asked to update packages. This might not be strictly necessary, so you can also skip this step. It should go without saying that as a non-even-beta version of the package, this is made available more as a preview than anything else. Many functions will work, but bugs are likely in many places. In case you do spot a bug, or have a suggestion, the best way is to open an issue on the repo. Otherwise, you can also just email me. 1.2 Whats it for? COINr is the first fully-flexible development and analysis environment for composite indicators and scoreboards. It allows: Flexible and fast development of composite indicators with no limits on aggregation levels, numbers of indicators, highly flexible set of methodological choices. In-depth statistical analysis of indicators and results, including multivariate analysis, statistical reweighting, uncertainty and sensitivity analysis, etc. Interactive data exploration and visualisation via Shiny apps which can be hosted online. HTML widgets for incorporation in interactive markdown documents. 1.3 Quick-start guide COINr is highly customisable, but equally allows composite indicator construction in a few commands. Taking the built-in ASEM dataset, we can assemble a composite indicator in a few steps. library(COINr) # assemble basic composite indicator object from input data ASEM &lt;- assemble(IndData = ASEMIndData, IndMeta = ASEMIndMeta, AggMeta = ASEMAggMeta) ## ----------------- ## Denominators detected - stored in .$Input$Denominators ## ----------------- ## ----------------- ## Indicator codes cross-checked and OK. ## ----------------- ## Number of indicators = 49 ## Number of units = 51 ## Number of reference years of data = 1 ## Years from 2018 to 2018 ## Number of aggregation levels = 3 above indicator level. ## ----------------- ## Aggregation level 1 with 8 aggregate groups: Physical, ConEcFin, Political, Instit, P2P, Environ, Social, SusEcFin ## Cross-check between metadata and framework = OK. ## Aggregation level 2 with 2 aggregate groups: Conn, Sust ## Cross-check between metadata and framework = OK. ## Aggregation level 3 with 1 aggregate groups: Index ## Cross-check between metadata and framework = OK. ## ----------------- # denominate data using specifications in ASEMIndMeta ASEM &lt;- denominate(ASEM) # normalise data ASEM &lt;- coin_normalise(ASEM, dset = &quot;Denominated&quot;) # Aggregate normalised data ASEM &lt;- coin_aggregate(ASEM, dset = &quot;Normalised&quot;) At this point, the dashboard for viewing the results interactively is still under development. Still, we can view a number of things. First, we may want to see the index structure: plotframework(ASEM) This is an interactive HTML widget which can be embedded into HTML documents (such as this page). We can also analyse indicator statistics: library(reactable) library(magrittr) ASEM &lt;- getStats(ASEM, dset = &quot;Raw&quot;) ASEM$Analysis$Raw$StatTable %&gt;% reactable::reactable(defaultPageSize = 5, highlight = TRUE, wrap = F) plot indicator distributions, plotIndDist(ASEM, type = &quot;Violindot&quot;, inames = &quot;Political&quot;) and visualise and explore overall results in an interactive dashboard Figure 1.1: Results dashboard screenshot COINr has, or will have, many more features. Among those that are already implemented and in various stages of testing: Unlimited indicators, units, aggregation levels Denomination of indicators Indicator visualisation via static plots and dashboards Indicator statistics and missing data analysis Imputation of missing data via various methods Outlier analysis and treatment Normalisation via various methods Aggregation of indicators via various methods Multivariate analysis (PCA) and correlation analysis Interactive re-weighting Export to Excel And those that will be included soon, among others: Automatic re-weighting Grouping units by e.g. income groups, size groups Support for panel data, i.e. indexes for multiple years What-if experiments, comparing alternative versions of the index Sensitivity analysis, robustness to methodological assumptions, weights, etc. Import/export to the COIN Tool "],["introduction.html", "Chapter 2 Introduction 2.1 How to use COINr 2.2 Terminology 2.3 Tips for using COINr", " Chapter 2 Introduction The COINr package is a comprehensive development and analysis environment for composite indicators and scoreboards, featuring a range of tools for building, visualising and analysing. This vignette is a work in progress and will be expanded as the COINr project progresses. 2.1 How to use COINr There are two main ways to use COINr. The first is to use the functions as standalone tools for your own specific use. For example, coin_normalise.R will take a data frame as an input, and normalise the columns according to the options specified in its input, outputting another data frame. The second way is to work inside what Ill call the COINrverse (with tongue firmly in cheek). What this means is that all operations are performed on a single object, the COIN object, which stores all data, all analysis, parameters, and methodological choices made along the way. The COINrverse approach enables the full feature set of COINr, because some functions only work on COIN objects - for example, exporting all results to Excel in one command, or running an uncertainty/sensitivity analysis. Indeed, COINr is built mainly for COINrverse use, but functions have been written with the flexibility to also accommodate independent use where possible. More details on how the COINrverse works can be found in XXX. 2.2 Terminology Lets clearly define a few terms first to avoid confusion later on. An indicator is a variable which has an observed value for each unit. Indicators might be things like life expectancy, CO2 emissions, number of tertiary graduates, and so on. A unit is one of the entities that you are comparing with indicators. Often, units are countries, but they could also be regions, universities, individuals or even competing policy options (the latter is the realm of multicriteria decision analysis). Together, indicators and units form the main input data frame for COINr (units as rows, and indicators as columns). 2.3 Tips for using COINr 2.3.1 Ordering Currently, COINr is somewhat dependent on the order of the units. Although you can input your data in any order you like (as long as you follow the rules in Data Input), in some cases the order does matter. For example, if you want to denominate your data by a separate data frame of indicators (not in the COIN), you will have to make sure that the units (rows) correspond to the same order of rows as your indicator data. In future updates this dependence on order should be removed, because it is a possible source of errors. For now though, just keep ordering in mind. Its worth mentioning that the row order never changes in the .$Data folder. However, if you screen units using a minimum data requirement (e.g. using datacheck()), then the number of units can change. This should also be kept in mind. 2.3.2 Syntax Where possible, COINr functions use a common syntax to keep things simple. For example: dset always refers to the name of the data set that is found in .$Data. For example, dset = \"Normalised\" will return .$Data$Normalised. The only exception is dset = \"Denominators\", which returns .$Input$Denominators. The argument dset is used in many COINr functions because they have to know which data set to operate on. More to be added here. "],["data-input.html", "Chapter 3 Data Input 3.1 Introduction 3.2 The three inputs 3.3 Putting everything together 3.4 Moving on", " Chapter 3 Data Input 3.1 Introduction Where possible COINr functions can be used as standalone functions, typically on data frames of indicator data, for operations such as normalisation, imputation and so on. The full functionality of COINr is however harnessed by assembling the indicator data, and the structure of the index, into a COIN Object (catchier name pending). The COIN object is a structured list, which neatly stores the various data sets, parameters, analyses and methodological decisions in one place. There are various reasons for doing this: It simplifies operations because functions know where data and parameters are. Therefore, COINr operations typically follow a syntax of the form COINobj &lt;- COINr_function(COINobj, &lt;methodological settings&gt;), updating the COIN object with new results and data sets generated by the function. This avoids having to repeatedly specify indicator names, structure, etc, as separate arguments. It keeps things organised and avoids a workspace of dozens of variables. It keeps a record of methodological decisions - this allows results to be easily regenerated following what if experiments, such as removing or changing indicators etc (see Section on adjustments and reruns TO ADD). The logic of doing this will become clearer as you build your index. If you only want to use the COINr functions on data frames, you can probably skip this chapter. 3.2 The three inputs To build a COIN object, three ingredients (data frames) are needed to begin with. In short, they are the indicator data, the indicator metadata, and the aggregation metadata. Here, each will be explained separately. Inputting the data in the first place is where you will do most of the work, because you have to get your data in a format that COINr understands. But once you have got your data assembled, COINr should do most of the hard work, so hang in there! 3.2.1 Indicator data The indicator data is a data frame which, shockingly, specifies the data for the indicators. However, it can do more than that, and also some rules have to be followed. The easiest way to explain is to start with an example. library(COINr) head(ASEMIndData) ## # A tibble: 6 x 60 ## UnitName UnitCode Group_GDP Group_GDPpc Group_Pop Group_EurAsia Year Den_Area ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austria AUT L XL M Europe 2018 83871 ## 2 Belgium BEL L L L Europe 2018 30528 ## 3 Bulgaria BGR S S M Europe 2018 110879 ## 4 Croatia HRV S M S Europe 2018 56594 ## 5 Cyprus CYP S L S Europe 2018 9251 ## 6 Czech R~ CZE M L M Europe 2018 78867 ## # ... with 52 more variables: Den_Energy &lt;dbl&gt;, Den_GDP &lt;dbl&gt;, Den_Pop &lt;dbl&gt;, ## # LPI &lt;dbl&gt;, Flights &lt;dbl&gt;, Ship &lt;dbl&gt;, Bord &lt;dbl&gt;, Elec &lt;dbl&gt;, Gas &lt;dbl&gt;, ## # ConSpeed &lt;dbl&gt;, Cov4G &lt;dbl&gt;, Goods &lt;dbl&gt;, Services &lt;dbl&gt;, FDI &lt;dbl&gt;, ## # PRemit &lt;dbl&gt;, ForPort &lt;dbl&gt;, Embs &lt;dbl&gt;, IGOs &lt;dbl&gt;, UNVote &lt;dbl&gt;, ## # CostImpEx &lt;dbl&gt;, Tariff &lt;dbl&gt;, TBTs &lt;dbl&gt;, TIRcon &lt;dbl&gt;, RTAs &lt;dbl&gt;, ## # Visa &lt;dbl&gt;, StMob &lt;dbl&gt;, Research &lt;dbl&gt;, Pat &lt;dbl&gt;, CultServ &lt;dbl&gt;, ## # CultGood &lt;dbl&gt;, Tourist &lt;dbl&gt;, MigStock &lt;dbl&gt;, Lang &lt;dbl&gt;, Renew &lt;dbl&gt;, ## # PrimEner &lt;dbl&gt;, CO2 &lt;dbl&gt;, MatCon &lt;dbl&gt;, Forest &lt;dbl&gt;, Poverty &lt;dbl&gt;, ## # Palma &lt;dbl&gt;, TertGrad &lt;dbl&gt;, FreePress &lt;dbl&gt;, TolMin &lt;dbl&gt;, NGOs &lt;dbl&gt;, ## # CPI &lt;dbl&gt;, FemLab &lt;dbl&gt;, WomParl &lt;dbl&gt;, PubDebt &lt;dbl&gt;, PrivDebt &lt;dbl&gt;, ## # GDPGrow &lt;dbl&gt;, RDExp &lt;dbl&gt;, NEET &lt;dbl&gt; COINr comes prepackaged with some example data - here we are looking at indicator data from the ASEM Sustainable Connectivity Portal, which has an indicator data set covering 51 Asian and European countries. The first thing to notice is that each row is an observation (here, a country), and each column is a variable (mostly indicators, but also other things). Look at the structure of the data frame, working from left to right: UnitName [required] gives the name of each unit. Here, units are countries, so these are the names of each country. UnitCode [required] is a unique code assigned to each unit (country). This is very important, and is the main reference inside COINr for units. If your units are countries, I recommend using ISO Alpha-3 codes, because these are recognised by COINr for generating maps. It also makes data processing generally easier. Group_* [optional] Any column name that starts with Group_ is recognised as a group column rather than an indicator. You dont have to have any groups, but some COINr functions support specific operations on groups (e.g. imputation within group, and future updates plan to expand this capacity). You can have as many group columns as you want. Year [optional] gives the reference year of the data. This allows you to have multiple years of data, for example, you can have a value for a given country for 2018, and another value for the same country for 2019, and so on. Like groups, this feature is not yet fully developed in COINr. Den_*[optional] Any column names that begin with Den_* are recognised as denominators, i.e. indicators that are used to scale other indicators. Any remaining columns that do not use the names in this list are recognised as indicators. You will notice that all column (variable/indicator) names use short codes. This is to keep things concise in tables, rough plots etc. Indicator codes should be short, but informative enough that you know which indicator it refers to (e.g. Ind1 is not so helpful). In some COINr plots, codes are displayed, so you might want to take that into account. In any case, the full names of indicators, and other details, are also specified in the indicator metadata table - see the next section. Some important rules and tips to keep in mind are: The following columns are required. All other columns are optional: UnitCode UnitName At least one indicator column Columns dont have to be in any particular order, columns are identified by names rather than positions. You can have as many indicators and units as you like. Indicator codes and unit codes must have unique names. You cant use the same code twice otherwise bad things will happen. Avoid any accented characters or basically any characters outside of English - this can sometimes cause trouble with encoding. Column names are case-sensitive. Most things in COINr are built to have a degree of flexibility where possible, but column names need to be written exactly as they appear here for COINr to recognise them., 3.2.2 Indicator metadata The second data frame you need to input specifies the metadata of each indicator. This serves two purposes: first, to give details about each indicator, such as its name, its units and so on; and second, to specify the structure of the index. Heres what this looks like, for our example ASEM data set: head(ASEMIndMeta) ## # A tibble: 6 x 9 ## IndName IndCode Direction IndWeight Denominator IndUnit Agg1 Agg2 Agg3 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Logistics ~ LPI 1 1 &lt;NA&gt; Score 1~ Phys~ Conn Index ## 2 Internatio~ Flights 1 1 Den_Pop Thousan~ Phys~ Conn Index ## 3 Liner Ship~ Ship 1 1 &lt;NA&gt; Score Phys~ Conn Index ## 4 Border cro~ Bord 1 1 Den_Area Number ~ Phys~ Conn Index ## 5 Trade in e~ Elec 1 1 Den_Energy TWh Phys~ Conn Index ## 6 Trade in g~ Gas 1 1 Den_Energy Billion~ Phys~ Conn Index Notice that now, the table is flipped on its side (transposed), and each row is an indicator, and the columns specify other things. This is to keep the data in a tidy format. Lets go through the columns one by one. IndName [required] This is the full name of the indicator, which will be used in display plots. IndCode[required] A reference code for each indicator. These must be the same codes as specified in the indicator metadata. The codes must also be unique. Direction [required] The direction of each indicator - this takes values of either 1 or -1 for each indicator. A value of 1 means that higher values of the indicator correspond to higher values of the index, whereas -1 means the opposite. IndWeight [required] The initial weights assigned to each indicator. Weights are relative and do not need to sum to one, so you can simply put all 1s here if you dont know what else to put (the values can be adjusted later). Denominator [required??] These should be the indicator codes of one of the denominator variables for each indicator to be denominated. E.g. here Den_Pop specifies that the indicator should be denominated by the Den_Pop indicators (population, in this case). For any indicators that do not need denominating, just set NA. Denominators can also be specified later, so if you want you can leave this column out. See Denomination for more information. IndUnit [optional] The units of the indicator. This helps for keeping track of what the numbers actually mean, and can be used in plots. Agg* [required] Any column name that begins with Agg is recognised as a column specifying the aggregation group, and therefore the structure of the index. Aggregation columns should be in the order of the aggregation, but otherwise can have arbitrary names. Lets look at the aggregation columns in a bit more detail. Each column represents a separate aggregation level, so in the ASEM example here we have three aggregation levels - the pillars, the two sub-indexes, and the overall index. The entry of each column specifies which group each indicator falls in. So, the first column Agg1 specifies the pillar of each indicator. Again, each aggregation group (pillar, sub-index or index) is referenced by a unique code. The next column Agg2, gives the sub-index that the indicator belongs to. There is a bit of redundancy here, because obviously indicators in the same pillar must also belong to the same sub-index. Finally, Agg3 specifies that all indicators belong to the index. You can have as many Agg columns as you like, and the names dont have to be Agg1 etc, but could be e.g. Agg_Pillar, Agg_SubIndex, etc. However, they must begin with Agg, otherwise COINr will not recognise them. And they must appear in the order of the aggregation, i.e. lowest level of aggregation first, then working upwards. 3.2.3 Aggregation metadata The final data input is the aggregation metadata, which is also the simplest. Heres our example for the ASEM data set: head(ASEMAggMeta) ## # A tibble: 6 x 4 ## AgLevel Code Name Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Physical Physical 1 ## 2 2 ConEcFin Economic and Financial (Con) 1 ## 3 2 Political Political 1 ## 4 2 Instit Institutional 1 ## 5 2 P2P People to People 1 ## 6 2 Environ Environmental 1 This data frame simply consists of three columns for each aggregation level: *Code [required] The aggregation group codes. This column must end with Code, and the codes must match the codes in the corresponding column in the indicator metadata aggregation columns. *Name [required] The aggregation group names. This column must end with Name. *Weight [required] The aggregation group weights. This column must end with Weight. Again, these weights can be changed later on. Columns must appear in the order of the aggregation groups. 3.3 Putting everything together Having got all your data in the correct format, you can finally build it into a COIN object. From here, things start to get a bit easier. The function to build the COIN object is called assemble(). This function takes the three data frames mentioned and converts them into a so-called COIN Object, which is a hierarchical list that is structured in a way that is recognised by all COINr functions. Lets run assemble() using the built-in data sets to show how it works. ASEM &lt;- assemble(IndData = ASEMIndData, IndMeta = ASEMIndMeta, AggMeta = ASEMAggMeta) ## ----------------- ## Denominators detected - stored in .$Input$Denominators ## ----------------- ## ----------------- ## Indicator codes cross-checked and OK. ## ----------------- ## Number of indicators = 49 ## Number of units = 51 ## Number of reference years of data = 1 ## Years from 2018 to 2018 ## Number of aggregation levels = 3 above indicator level. ## ----------------- ## Aggregation level 1 with 8 aggregate groups: Physical, ConEcFin, Political, Instit, P2P, Environ, Social, SusEcFin ## Cross-check between metadata and framework = OK. ## Aggregation level 2 with 2 aggregate groups: Conn, Sust ## Cross-check between metadata and framework = OK. ## Aggregation level 3 with 1 aggregate groups: Index ## Cross-check between metadata and framework = OK. ## ----------------- The three inputs here are as follows: IndData which is the indicator data IndMeta which is the indicator metadata AggMeta which is the aggregation metadata And this outputs a COIN Object which you can name as you want (here we have called it ASEM). There are two further arguments to assemble() which are not used here, and they are: include - this is a character vector of indicator codes (i.e. codes that are found in IndData$IndCode) which specifies which indicators to include out of the IndData and IndMeta inputs. By default, all indicators are included, but this gives the option to only include certain indicators, if for example, you have several alternative data sources. exclude- this an analogous character vector of indicator codes, but specifying which indicators to exclude, if any. Again, by default, nothing is excluded. This may be easier to specify when creating a subset of indicators. The structure of the list is as follows. First, it is divided into five main sub-lists, which I am going to call folders: Input is the input data, and has the following entries: IndData The indicator data, after any exclusion of indicators IndMeta The indicator metadata, after any exclusion of indicators AggMeta The aggregation metadata, after any exclusion of indicators Original A list containing the original, unaltered inputs to assemble() Data is where the indicator data sets are stored. As you go through the construction, this will populated with more data sets, e.g. imputed data, treated data, aggregated data, and so on. On first assembly you will only see Raw present here. Parameters stores some useful parameters that are used by COINr functions, and may be of general interest, such as the indicator codes, unit codes, weights, and so on. Analysis is where analysis of the indicator data will be stored, including missing data analysis, indicator summary statistics, principal component analysis and so on. Method keeps a record of the methodological decisions made when constructing the composite indicator, for example the normalisation method and parameters, data treatment specifications, and so on. Apart from keeping a record of the construction, this also allows the entire results to be regenerated using the information stored in the COIN Object, this will be explained better in Chapter XXX. The logic of the COIN object is that COINr functions can take all the data and parameters that they need from it, and you only have to specify some particular parameters of the function. Then, outputs, such as new data sets, are returned back to the COIN object, which is added to and expanded as the analysis progresses. Apart from building the COIN Object, assemble() does a few other things: It checks that indicator codes are consistent between indicator data and indicator metadata It checks that required columns, such as indicator codes, are presenr It returns some basic information about the data that was input, such as the number of indicators, the number of units, the number of aggregation levels and the groups in each level. This is done so you can check what you have entered, and that it agrees with your expectations. 3.4 Moving on Now that you have a COIN Object, you can start using all the other functions in COINr to their full potential. Most functions will still work on standalone data frames, so you dont need to work with COIN objects if you prefer not to. "],["initial-visualisation-and-analysis.html", "Chapter 4 Initial visualisation and analysis 4.1 Structure 4.2 Distributions 4.3 Ranks and Maps 4.4 Statistics and analysis", " Chapter 4 Initial visualisation and analysis One of the first things to do with indicator data is to look at it, in as many ways as possible. This helps to get a feel for how the data is distributed between units/countries, how it may be spatially distibuted, and how indicators relate to one another. COINr includes various tools for visualising and analysing indicator data and the index structure. The types of plots generated by COINr fall into two categories: static plots, and interactive plots. static plots generate images in standard formats such as png, pdf and so on. Interactive plots generate javascript graphics, which have interactive elements such as zooming and panning, and information when you hover the mouse over. These latter type of plots are particularly useful for including in HTML documents, because they are self contained. For example, they can be used in R Markdown documents, then knitted to HTML, or embedded on websites (such as this one - see below), e.g. via the blogdown or bookdown packages. Javascript plots can also be rendered to png and other formats, so can also be used in static documents. The plotting tools here can be useful at any stage of building a composite indicator or scoreboard, from initial visualisation of the data, to checking the effects of data treatment, to visualising final index results. 4.1 Structure Independently from the indicator data, a good way to begin is to check the structure of the index. This can be done visually with the plotframework() function, which generates a sunburst plot of the index structure. plotframework(ASEM) The sunburst plot is useful for a few things. First, it shows the structure that COINr has understood. If you get an error here, it is probably an indication that something has gone wrong in the input of the structure, so go back to the input data and check. If it does successfully display the sunburst plot, you can check whether the structure agrees with your expectations. Second, it shows the effective weight of each indicator (the value is visible by hovering over each segment). This can reveal which indicators are implicitly weighted more than others, by e.g. having more or less indicators in the same aggregation groups. Finally, it can be a good way to communicate your index structure to other people. 4.2 Distributions Individual indicator distributions can be visualised in several different ways. For static plots, the main tool is plotIndDist() which generates histograms, boxplots, violin plots, dot plots and violin-dot plots. This is powered by ggplot2, and if you want to customise plots, you should use that directly. However, COINr plotting functions are intended as quick tools to visualise data, with easy access to the hierarchical data set. You can plot individual indicators: plotIndDist(ASEM, type = &quot;Histogram&quot;, inames = &quot;LPI&quot;) And you can also plot groups of indicators by calling aggregate names (notice that when multiple indicators are plotted, the indicator codes are used to label each plot, rather than indicator names, to save space): plotIndDist(ASEM, type = &quot;Violindot&quot;, inames = &quot;Physical&quot;) The plotIndDist() function has several arguments. In the first place, any indicator or aggregation (pillar, dimension, index etc) can be plotted by using the dset argument. If you have only just assembled the COIN Object, you will only have the Raw dataset, but any other dataset can be accessed, e.g. treated data set, aggregated data set, and so on. You can also target different levels using the aglev argument - for more details see the chapter on Helper functions. Stand-alone data frames are also supported by plotIndDist() (this can also be achieved directly by ggplot without too much effort): df &lt;- as.data.frame(matrix(rnorm(90),nrow = 30, ncol = 3)) colnames(df) &lt;- c(&quot;Dogs&quot;, &quot;Cats&quot;, &quot;Rabbits&quot;) plotIndDist(df, type = &quot;Box&quot;) COINr also includes some interactive plots, which are embedded into apps (see later), but can be used for your own purposes, such as embedding in HTML documents or websites. iplotIndDist(ASEM, &quot;Raw&quot;, &quot;Renew&quot;, ptype = &quot;Violin&quot;) Since all the plotting functions output plot objects (plotly objects for iplotIndDist, and ggplot2 plot objects for plotIndDist), you can also modify them if you want to customise the plots. This might be a helpful workflow - to use COINrs default options and then tweak the plot to your liking. In a very simple example, here we just change the title. iplotIndDist(ASEM, &quot;Raw&quot;, &quot;Flights&quot;, ptype = &quot;Histogram&quot;) %&gt;% plotly::layout(title = &quot;Customised plot&quot;) If you are purely interested in exploring the data, rather than presenting it to someone else, the plots here are also embedded into a Shiny app which lets you quickly explore and compare indicator distributions - see Data Treatment for more details on this. 4.3 Ranks and Maps While the previous functions concerned plotting the statistical distributions of each indicator, functions are also available for plotting the indicator values in order or on a map. iplotBar(ASEM, dset = &quot;Raw&quot;, isel = &quot;Embs&quot;, usel = &quot;SGP&quot;) Here, a single indicator is plotted in order as a bar chart. There is an optional argument to highlight one or more units, using the usel argument. From a different perspective, we can plot the same data on a map: iplotMap(ASEM, dset = &quot;Raw&quot;, isel = &quot;Embs&quot;) Note that this only works if IndData$UnitCode correspond to ISO alpha-3 country codes. If you want to do some more sophisticated mapping R, Plotly has many mapping options, but R in general has all kinds of mapping packages, you just have to search for them. COINr uses Plotly maps to keep things simple and to not depend on too many packages. COINr has yet more tools to plot data, but lets leave it at that for the moment. Other tools will be introduced in other chapters. 4.4 Statistics and analysis Aside from plots, COINr gives a fairly detailed statistical analysis of initial indicator data. The function getStats() returns a series of statistics which can be aimed at any of the data sets in the .$Data folder. You can also specify if you want the output to be returned back to the COIN, or to a separate list. # get stats ASEM &lt;- getStats(ASEM, dset = &quot;Raw&quot;, out2 = &quot;COIN&quot;) ## Number of collinear indicators = 10 ## Number of signficant negative indicator correlations = 324 ## Number of indicators with high denominator correlations = 18 # display in table using Reactable # (note the use of helper function roundDF() to round the values to a sensible number of decimals) ASEM$Analysis$Raw$StatTable %&gt;% roundDF() %&gt;% reactable::reactable(resizable = TRUE, bordered = TRUE, highlight = TRUE, defaultPageSize = 10) The columns of this table give all kind of information from max, min, standard deviation, etc, to the presence of outliers and amount of missing data. Apart from the overall statistics for each indicator, getStats also returns a few other things: .$Outliers, which flags individual outlying points using the relation to the interquartile range .$Correlations, which gives a correlation matrix between all indicators in the data set .$DenomCorrelations, which gives the correlations between indicators and any denominators Each of these aspects will be explained in more detail in later chapters (to add which), so for the moment it is enough to mention that they exist. "],["missing-data-and-imputation.html", "Chapter 5 Missing data and Imputation 5.1 Concept", " Chapter 5 Missing data and Imputation Imputation is the process of estimating missing data points. This can be done in any number of ways, and as usual, the best way depends on the problem. Of course, you dont have to impute data. You can also simply delete any indicator or unit that has missing values, although in many cases this can be too restrictive. Reasonable results can still be obtained despite small amounts of missing data, although if too much data is missing, the uncertainty can be too high to give a meaningful analysis. As usual, it is a balance. A good first step is to check how much data is missing, and where (see below). Units with very high amounts of missing data can be screened out. Small amounts of missing data can then be imputed. 5.1 Concept The simplest imputation approach is to use values of other units to estimate the missing point. Typically, this could involve the sample mean or median of the indicator. Heres some data from the ASEM data set regarding the average connection speed of each country. Towards the end there are some missing values, so lets view the last few rows: library(COINr) Ind1 &lt;- data.frame(Country = ASEMIndData$UnitName, ConSpeed = ASEMIndData$ConSpeed) Ind1[40:nrow(Ind1),] ## Country ConSpeed ## 40 Korea 28.6 ## 41 Lao PDR NA ## 42 Malaysia 8.9 ## 43 Mongolia NA ## 44 Myanmar NA ## 45 New Zealand 14.7 ## 46 Pakistan NA ## 47 Philippines 5.5 ## 48 Russian Federation 11.8 ## 49 Singapore 20.3 ## 50 Thailand 16.0 ## 51 Vietnam 9.5 Using our simple imputation method, we just replace the NA values with the sample mean. Ind1$ConSpeed &lt;- replace(Ind1$ConSpeed, is.na(Ind1$ConSpeed), mean(Ind1$ConSpeed, na.rm = T)) Ind1[40:nrow(Ind1),] ## Country ConSpeed ## 40 Korea 28.60000 ## 41 Lao PDR 14.28605 ## 42 Malaysia 8.90000 ## 43 Mongolia 14.28605 ## 44 Myanmar 14.28605 ## 45 New Zealand 14.70000 ## 46 Pakistan 14.28605 ## 47 Philippines 5.50000 ## 48 Russian Federation 11.80000 ## 49 Singapore 20.30000 ## 50 Thailand 16.00000 ## 51 Vietnam 9.50000 This approach can be reasonable if countries are somehow similar in that indicator. However, other perhaps more informative ways are available: Substituting by the mean or median of the country group (e.g. income group or continent) If time series data is available, use the latest known data point Then there is another class of methods which use data from other indicators to estimate the missing point. The core idea here is that if the indicators are related to one another, it is possible to guess the missing point by using known values of other indicators. This can take the form of: Simply substituting the mean or median of the normalised values of the other indicators Subsituting the mean or median of normalised values of the other indicators within the aggregation group Using a more formal approach, based on regression "],["denomination.html", "Chapter 6 Denomination 6.1 Concept 6.2 Denominating in COINr 6.3 When to denominate, and by what?", " Chapter 6 Denomination The first section here gives a bit of introduction to the concept of denomination. If you just want to know how to denominate in COINr, skip to the section on Denominating in COINr. 6.1 Concept Denomination refers to the operation of dividing one indicator by another. But why should we do that? As anyone who has ever looked at a map will know, countries come in all different sizes. The problem is that many indicators, on their own, are strongly linked to the size of the country. That means that if we compare countries using these indicators directly, we will often get a ranking that has roughly the biggest countries at the top, and the smallest countries at the bottom. To take an example, lets examine some indicators in the ASEM data set, and introduce another plotting function in the process. # load COINr package library(COINr) library(magrittr) # for pipe operations # build ASEM index ASEM &lt;- build_ASEM() # plot international trade in goods against GDP iplotIndDist2(ASEM, dsets = c(&quot;Denominators&quot;, &quot;Raw&quot;), inames = c(&quot;Den_GDP&quot;, &quot;Goods&quot;)) # (note: need to fix labelling and units of denominators) The function iplotIndDist2() is similar to iplotIndDist() but allows plotting two indicators against each other. You can pick any indicator from any data set for each, including denominators. What are these denominators anyway? Denominators are indicators that are used to scale other indicators, in order to remove the size effect. Typically, they are those related to physical or economic size, including GDP, population, land area and so on. Anyway, looking at the plot above, it is clear that that countries with a higher GDP have a higher international trade in international goods (e.g. Germany, China, UK, Japan, France), which is not very surprising. The problem comes when we want to include this indicator as a measure of connectivity: on its own, trade in goods simply summarises having a large economy. What is more interesting, is to measure international trade per unit GDP, and this is done by dividing (i.e. denominating) the international trade of each country by its GDP. Lets do that manually here and see what we get. # divide trade by GDP tradeperGDP &lt;- ASEM$Data$Raw$Goods/ASEM$Input$Denominators$Den_GDP # bar chart: add unit names first iplotBar(data.frame(UnitCode=ASEM$Parameters$UnitCodes, TradePerGDP = tradeperGDP)) Now the picture is completely different - small countries like Slovakia, Czech Republic and Singapore have the highest values. The rankings here are completely different because the meanings of these two measures are completely different. Denomination is in fact a nonlinear transformation, because every value is divided by a different value (each country is divided by its own unique GDP, in this case). That doesnt mean that denominated indicators are suddenly more right than the before their denomination, however. Trade per GDP is a useful measure of how much a countrys economy is dependent on international trade, but in terms of economic power, it might not be meaningful to scale by GDP. In summary, it is important to consider the meaning of the indicator compared to what you want to actually measure. More precisely, indicators can be thought of as either intensive or extensive variables. Intensive variables are not (or only weakly) related to the size of the country, and allow fair comparisons between countries of different sizes. Extensive variables, on the contrary, are strongly related to the size of the country. This distinction is well known in physics, for example. Mass is related to the size of the object and is an extensive variable. If we take a block of steel, and double its size (volume), we also double its mass. Density, which is mass per unit volume, is an intensive quantity: if we double the size of the block, the density remains the same. An example of an extensive variable is population. Bigger countries tend to have bigger populations. An example of an intensive variable is population density. This is no longer dependent on the physical size of the country. The summary here is that an extensive variable becomes an intensive variable when we divide it by a denominator. 6.2 Denominating in COINr Denomination is fairly simple to do in R, its just dividing one vector by another. Nevertheless, COINr has a dedicated function for denominating which makes life easier and helps you to track what you have done. Before we get to that, its worth mentioning that COINr has a few built-in denominators sourced from the World Bank. It looks like this: WorldDenoms ## # A tibble: 249 x 7 ## UnitName UnitCode Den_GDP Den_Pop Den_Area Den_GDPpc Den_IncomeGroup ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan AFG 192911040~ 380417~ 652860 507.103431~ Low income ## 2 Albania ALB 152791832~ 2854191 27400 5353.24485~ Upper middle in~ ## 3 Algeria DZA 171091289~ 430530~ 2381740 3973.96407~ Lower middle in~ ## 4 American S~ ASM 636000000 55312 200 11466.6907~ Upper middle in~ ## 5 Andorra AND 315405798~ 77142 470 40886.3911~ High income ## 6 Angola AGO 888156977~ 318252~ 1246700 2790.72661~ Lower middle in~ ## 7 Anguilla AIA NA NA NA NA NA ## 8 Antarctica ATA NA NA NA NA NA ## 9 Antigua an~ ATG 166196296~ 97118 440 17112.8211~ High income ## 10 Argentina ARG 445445177~ 449387~ 2736690 9912.28180~ Upper middle in~ ## # ... with 239 more rows and the metadata can be found by calling ?WorldDenoms. Data here is the latest available as of February 2021 and I would recommend using these only for exploration, then updating your data yourself. To denominate your indicators in COINr, the function to call is denominate(). Like other COINr functions, this can be used either independently on a data frame of indicators, or on COINs. Consider that in all cases you need three main ingredients: Some indicator data that should be denominated Some other indicators to use as denominators A mapping to say which denominators (if any) to use for each indicator. 6.2.1 On COINs If you are working with a COIN, the indicator data will be present in the .$Data folder. If you specified any denominators in IndData (i.e. columns beginning with Den_) when calling assemble() you will also find them in .$Input$Denominators. Finally, if you specified a Denominator column in IndMeta when calling assemble() then the mapping of denominators to indicators will also be present. # The raw indicator data which will be denominated ASEM$Data$Raw ## # A tibble: 51 x 56 ## UnitName UnitCode Group_GDP Group_GDPpc Group_Pop Group_EurAsia Year LPI ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austria AUT L XL M Europe 2018 4.10 ## 2 Belgium BEL L L L Europe 2018 4.11 ## 3 Bulgaria BGR S S M Europe 2018 2.81 ## 4 Croatia HRV S M S Europe 2018 3.16 ## 5 Cyprus CYP S L S Europe 2018 3.00 ## 6 Czech R~ CZE M L M Europe 2018 3.67 ## 7 Denmark DNK L XL M Europe 2018 3.82 ## 8 Estonia EST S M S Europe 2018 3.36 ## 9 Finland FIN M XL M Europe 2018 3.92 ## 10 France FRA XL L L Europe 2018 3.90 ## # ... with 41 more rows, and 48 more variables: Flights &lt;dbl&gt;, Ship &lt;dbl&gt;, ## # Bord &lt;dbl&gt;, Elec &lt;dbl&gt;, Gas &lt;dbl&gt;, ConSpeed &lt;dbl&gt;, Cov4G &lt;dbl&gt;, ## # Goods &lt;dbl&gt;, Services &lt;dbl&gt;, FDI &lt;dbl&gt;, PRemit &lt;dbl&gt;, ForPort &lt;dbl&gt;, ## # Embs &lt;dbl&gt;, IGOs &lt;dbl&gt;, UNVote &lt;dbl&gt;, CostImpEx &lt;dbl&gt;, Tariff &lt;dbl&gt;, ## # TBTs &lt;dbl&gt;, TIRcon &lt;dbl&gt;, RTAs &lt;dbl&gt;, Visa &lt;dbl&gt;, StMob &lt;dbl&gt;, ## # Research &lt;dbl&gt;, Pat &lt;dbl&gt;, CultServ &lt;dbl&gt;, CultGood &lt;dbl&gt;, Tourist &lt;dbl&gt;, ## # MigStock &lt;dbl&gt;, Lang &lt;dbl&gt;, Renew &lt;dbl&gt;, PrimEner &lt;dbl&gt;, CO2 &lt;dbl&gt;, ## # MatCon &lt;dbl&gt;, Forest &lt;dbl&gt;, Poverty &lt;dbl&gt;, Palma &lt;dbl&gt;, TertGrad &lt;dbl&gt;, ## # FreePress &lt;dbl&gt;, TolMin &lt;dbl&gt;, NGOs &lt;dbl&gt;, CPI &lt;dbl&gt;, FemLab &lt;dbl&gt;, ## # WomParl &lt;dbl&gt;, PubDebt &lt;dbl&gt;, PrivDebt &lt;dbl&gt;, GDPGrow &lt;dbl&gt;, RDExp &lt;dbl&gt;, ## # NEET &lt;dbl&gt; # The denominators ASEM$Input$Denominators ## # A tibble: 51 x 11 ## UnitCode UnitName Year Group_GDP Group_GDPpc Group_Pop Group_EurAsia ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 AUT Austria 2018 L XL M Europe ## 2 BEL Belgium 2018 L L L Europe ## 3 BGR Bulgaria 2018 S S M Europe ## 4 HRV Croatia 2018 S M S Europe ## 5 CYP Cyprus 2018 S L S Europe ## 6 CZE Czech R~ 2018 M L M Europe ## 7 DNK Denmark 2018 L XL M Europe ## 8 EST Estonia 2018 S M S Europe ## 9 FIN Finland 2018 M XL M Europe ## 10 FRA France 2018 XL L L Europe ## # ... with 41 more rows, and 4 more variables: Den_Area &lt;dbl&gt;, ## # Den_Energy &lt;dbl&gt;, Den_GDP &lt;dbl&gt;, Den_Pop &lt;dbl&gt; # The mapping of denominators to indicators (see Denominator column) ASEM$Input$IndMeta ## # A tibble: 49 x 9 ## IndName IndCode Direction IndWeight Denominator IndUnit Agg1 Agg2 Agg3 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Logistics~ LPI 1 1 &lt;NA&gt; Score ~ Phys~ Conn Index ## 2 Internati~ Flights 1 1 Den_Pop Thousa~ Phys~ Conn Index ## 3 Liner Shi~ Ship 1 1 &lt;NA&gt; Score Phys~ Conn Index ## 4 Border cr~ Bord 1 1 Den_Area Number~ Phys~ Conn Index ## 5 Trade in ~ Elec 1 1 Den_Energy TWh Phys~ Conn Index ## 6 Trade in ~ Gas 1 1 Den_Energy Billio~ Phys~ Conn Index ## 7 Average c~ ConSpeed 1 1 &lt;NA&gt; Mbps Phys~ Conn Index ## 8 Den_Pop c~ Cov4G 1 1 &lt;NA&gt; Percent Phys~ Conn Index ## 9 Trade in ~ Goods 1 1 Den_GDP Trilli~ ConE~ Conn Index ## 10 Trade in ~ Services 1 1 Den_GDP Millio~ ConE~ Conn Index ## # ... with 39 more rows COINrs denominate() function knows where to look for each of these ingredients, so we can simply call: ASEM &lt;- denominate(ASEM) which will return a new data set .Data$Denominated. To return the dataset directly, rather than outputting an updated COIN, you can also set out2 = \"df\" (this is a common argument to many functions which can be useful if you want to examine the result directly). You can also change which indicators are denominated, and by what. # Get denominator specification from metadata denomby_meta &lt;- ASEM$Input$IndMeta$Denominator # Example: we want to change the denominator of flights from population to GDP denomby_meta[ASEM$Input$IndMeta$IndCode == &quot;Flights&quot;] &lt;- &quot;Den_GDP&quot; # Now re-denominate. Return data frame for inspection ASEM &lt;- denominate(ASEM, dset = &quot;Raw&quot;, specby = &quot;user&quot;, denomby = denomby_meta) Here we have changed the denominator of one of the indicators, Flights, to GDP. This is done by creating a character vector denomby_meta (copied from the original denominator specification) which has an entry for each indicator, specifying which denominator to use, if any. We then changed the entry corresponding to Flights. This overwrites any previous denomination. If you want to keep and compare alternative specifications, see the chapter on (chap to add). Lets compare the raw Flights data with the Flights per GDP data: # plot raw flights against denominated iplotIndDist2(ASEM, dsets = c(&quot;Raw&quot;, &quot;Denominated&quot;), inames = &quot;Flights&quot;) Clearly, the denominated and raw indicators are very different from one another, reflecting the completely different meaning. 6.2.2 On data frames If you are just working with data frames, you need to supply the three ingredients directly to the function. Here we will take some of the ASEM data for illustration (recalling that both indicator and denominator data is specified in ASEMIndMeta). # a small data frame of indicator data IndData &lt;- ASEMIndData[c(&quot;Goods&quot;, &quot;Services&quot;, &quot;FDI&quot;)] IndData ## # A tibble: 51 x 3 ## Goods Services FDI ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 278. 108. 5 ## 2 598. 216. 5.71 ## 3 42.8 13.0 1.35 ## 4 28.4 17.4 0.387 ## 5 8.77 15.2 1.23 ## 6 274. 43.5 3.88 ## 7 147. 114. 9.1 ## 8 28.2 10.2 0.580 ## 9 102. 53.8 6.03 ## 10 849. 471. 30.9 ## # ... with 41 more rows # two selected denominators Denoms &lt;- ASEMIndData[c(&quot;Den_Pop&quot;, &quot;Den_GDP&quot;)] # denominate the data IndDataDenom &lt;- denominate(IndData, denomby = c(&quot;Den_GDP&quot;, NA, &quot;Den_Pop&quot;), denominators = Denoms) IndDataDenom ## # A tibble: 51 x 3 ## Goods Services FDI ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.712 108. 0.000572 ## 2 1.28 216. 0.000500 ## 3 0.804 13.0 0.000191 ## 4 0.554 17.4 0.0000924 ## 5 0.437 15.2 0.00104 ## 6 1.40 43.5 0.000365 ## 7 0.478 114. 0.00159 ## 8 1.21 10.2 0.000443 ## 9 0.426 53.8 0.00109 ## 10 0.344 471. 0.000476 ## # ... with 41 more rows Since the input is recognised as a data frame, you dont need to specify any other arguments, and the output is automatically a data frame. Note how denomby works: here it specifies that that Goods should be denominated by Den_GDP, that Services should not be denominated, and that FDI should be denominated by Den_Pop. 6.3 When to denominate, and by what? Denomination is mathematically very simple, but from a conceptual point of view it needs to be handled with care. As we have shown, denominating an indicator will usually completely change it, and will have a corresponding impact on the results. Two ways of looking at the problem are first, from the conceptual point of view. Consider each indicator and whether it fits with the aim of your index. Some indicators are anyway intensive, such as the percentage of tertiary graduates. Others, such as trade, will be strongly linked to the size of the country. In those cases, consider whether countries with high trade values should have higher scores in your index or not? Or should it be trade as a percentage of GDP? Or trade per capita? Each of these will have different meanings. Sometimes extensive variables will anyway be the right choice. The Lowy Asia Power Index measures the power of each country in an absolute sense: in this case, the size of the country is all-important and e.g. trade or military capabilities per capita would not make much sense. The second (complimentary) way to approach denomination is from a statistical point of view. We can check which indicators are strongly related to the size of a country by correlating them with some typical denominators, such as the ones used here. The getStats() function does just this, checking the correlations between each indicator and each denominator, and flagging any possible high correlations. # get statistics on raw data set ASEM &lt;- getStats(ASEM, dset = &quot;Raw&quot;, out2 = &quot;COIN&quot;, t_denom = 0.8) ## Number of collinear indicators = 10 ## Number of signficant negative indicator correlations = 324 ## Number of indicators with high denominator correlations = 15 # get the result ctable &lt;- ASEM$Analysis$Raw$DenomCorrelations # return only columns that have entries with correlation above 0.8 ctable[,colSums((abs(ctable) &gt; 0.8))&gt;0] ## Flights Goods Services FDI PRemit Tariff ## Den_Area 0.004086325 0.04516500 0.01792843 0.2192345 0.1132941 0.3736916 ## Den_Energy 0.280719950 0.36006001 0.42590268 0.6536837 0.4639201 0.7945156 ## Den_GDP 0.845140925 0.84178477 0.86759186 0.9627225 0.9161336 0.2961538 ## Den_Pop 0.025920170 0.07065718 0.23821808 0.4772343 0.2635235 0.8762061 ## RTAs Visa StMob Research Pat CultGood ## Den_Area -0.8930525 -0.8858828 0.3838843 0.10899708 -0.06388983 -0.001505749 ## Den_Energy -0.7191475 -0.7501379 0.4869492 0.33615583 0.29043647 0.312864841 ## Den_GDP -0.2755920 -0.2080551 0.8573485 0.89007903 0.83013272 0.849055254 ## Den_Pop -0.4544421 -0.4539003 0.2041878 0.08386292 0.06948564 0.052972424 ## MigStock Poverty FemLab ## Den_Area 0.4749737 0.0860072 -0.1099044 ## Den_Energy 0.7703435 0.6413876 -0.5970645 ## Den_GDP 0.9104204 0.2622643 -0.2373947 ## Den_Pop 0.4772082 0.9371589 -0.8455970 The matrix that is displayed above only includes columns where there is a correlation value (between an indicator and any denominator) of greater than 0.8. The results show some interesting patterns: Many indicators have a high positive correlation with GDP, including flights, trade, foreign direct investment (very high), personal remittances, research, stock of migrants, and so on. Bigger countries, in terms of land area, tend to have less trade agreements (RTAs) and a more restrictive visa policy Larger populations are associated with higher levels of poverty The purpose here is not to draw causal links between these quantities, although they might reveal interesting patterns. Rather, these might suggest which quantities to denominate by, if the choices also work on a conceptual level. "],["data-treatment.html", "Chapter 7 Data Treatment 7.1 Example one 7.2 Example two", " Chapter 7 Data Treatment Some significant applications are demonstrated in this chapter. 7.1 Example one 7.2 Example two "],["normalisation.html", "Chapter 8 Normalisation", " Chapter 8 Normalisation Some stuff. "],["aggregation.html", "Chapter 9 Aggregation", " Chapter 9 Aggregation Stuff. "],["weighting.html", "Chapter 10 Weighting 10.1 Approaches to weighting 10.2 Interactive re-weighting with ReW8R 10.3 Automatic re-weighting 10.4 Manual re-weighting", " Chapter 10 Weighting Strictly speaking, weighting comes before aggregation. However, in order to understand the effects of weights, we need to aggregate the index first. Weighting in composite indicators is a thorny issue, which attracts considerable attention and is often one of the main focuses of critics. 10.1 Approaches to weighting Outline of some key approaches 10.2 Interactive re-weighting with ReW8R A description 10.3 Automatic re-weighting The weight optimisation algorithm 10.4 Manual re-weighting Further options for weighting. "],["helper-functions.html", "Chapter 11 Helper functions 11.1 Importing and exporting 11.2 Selecting data sets and indicators 11.3 Rounding data frames", " Chapter 11 Helper functions 11.1 Importing and exporting COINr has a couple of useful functions to help import and export data and metadata. You might have heard of the COIN Tool which is an Excel-based tool for building and analysing composite indicators, similar in fact to COINr1. With the coinToolIn() function you can import data directly from the COIN Tool to cross check or extend your analysis in COINr. To demonstrate, we can take the example version of the COIN Tool, which you can download here. Then its as simple as running: library(COINr) # This is the file path and name where the COIN Tool is downloaded to # You could also just put it in your project directory. fname &lt;- &quot;C:/Users/becke/Downloads/COIN_Tool_v1_LITE_exampledata.xlsm&quot; dflist &lt;- COINToolIn(fname) ## Imported 15 indicators and 28 units. The output of this function is a list with the three data frame inputs to assemble(). dflist ## $IndData ## # A tibble: 28 x 17 ## UnitName UnitCode ind.01 ind.02 ind.03 ind.04 ind.05 ind.06 ind.07 ind.08 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austria AT 13.3 80.4 492. 14.9 68.8 34 3.7 87.6 ## 2 Belgium BE 15.1 71.8 503. 7 59.6 24 5.2 81.2 ## 3 Bulgaria BG 12.3 78.1 440. 2.2 51.3 15 10.6 72 ## 4 Cyprus CY 14 76 438. 6.9 16.7 23 3.6 73.4 ## 5 Czech R~ CZ 13.5 87.6 491. 8.8 73.2 27 3.9 86.7 ## 6 Germany DE 9.7 80.2 508. 8.5 46.3 30 5.6 90.1 ## 7 Denmark DK 9.7 73 504. 27.7 40.6 39 3.8 83.9 ## 8 Estonia EE 8.6 83.3 524. 15.7 35.7 37 4.1 77.1 ## 9 Greece EL 11.8 70 458. 4 31.5 30 3.9 49.2 ## 10 Spain ES 14.9 57.4 491. 9.4 34.8 33 11.4 68 ## # ... with 18 more rows, and 7 more variables: ind.09 &lt;dbl&gt;, ind.10 &lt;dbl&gt;, ## # ind.11 &lt;dbl&gt;, ind.12 &lt;dbl&gt;, ind.13 &lt;dbl&gt;, ind.14 &lt;dbl&gt;, ind.15 &lt;dbl&gt; ## ## $IndMeta ## # A tibble: 15 x 9 ## IndCode IndName GPupper GPlower Direction IndWeight Agg1 Agg2 Agg3 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 ind.01 Pre-primary pu~ NA NA -1 0.4 sp.01 p.01 Index ## 2 ind.02 Share of popul~ NA NA 1 0.3 sp.01 p.01 Index ## 3 ind.03 Reading, maths~ NA NA 1 0.3 sp.01 p.01 Index ## 4 ind.04 Recent training NA NA 1 0.3 sp.02 p.01 Index ## 5 ind.05 VET students NA NA 1 0.35 sp.02 p.01 Index ## 6 ind.06 High computer ~ NA NA 1 0.35 sp.02 p.01 Index ## 7 ind.07 Early leavers ~ NA NA -1 0.7 sp.03 p.02 Index ## 8 ind.08 Recent graduat~ NA NA 1 0.3 sp.03 p.02 Index ## 9 ind.09 Activity rate ~ NA NA 1 0.5 sp.04 p.02 Index ## 10 ind.10 Activity rate ~ NA NA 1 0.5 sp.04 p.02 Index ## 11 ind.11 Long-term unem~ NA NA -1 0.4 sp.05 p.03 Index ## 12 ind.12 Underemployed ~ NA NA -1 0.6 sp.05 p.03 Index ## 13 ind.13 Higher educati~ NA NA -1 0.4 sp.06 p.03 Index ## 14 ind.14 ISCED 5-8 prop~ NA NA -1 0.1 sp.06 p.03 Index ## 15 ind.15 Qualification ~ NA NA -1 0.5 sp.06 p.03 Index ## ## $AggMeta ## # A tibble: 10 x 4 ## AgLevel Code Name Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 4 Index European Skills Index 1 ## 2 3 p.01 Skills Development 0.3 ## 3 3 p.02 Skills Activation 0.3 ## 4 3 p.03 Skills Matching 0.4 ## 5 2 sp.01 Compulsory education 0.5 ## 6 2 sp.02 Training and tertiary education 0.5 ## 7 2 sp.03 Transition to work 0.5 ## 8 2 sp.04 Activity rates 0.5 ## 9 2 sp.05 Unemployment 0.4 ## 10 2 sp.06 Skills mismatch 0.6 Because the COIN Tool uses numeric codes for indicators such as ind.01, you might want slightly more informative codes. The best way to do this is to name the codes yourself, but a quick solution is to set makecodes = TRUE in COINToolIn(). This generates short codes based on the indicator names. It will not yield perfect results, but for a quick analysis it might be sufficient. At least, you could use this and then modify the results by hand. dflist &lt;- COINToolIn(fname, makecodes = TRUE) ## Imported 15 indicators and 28 units. dflist$IndMeta$IndCode ## [1] &quot;Pre-Pupi&quot; &quot;SharPopu&quot; &quot;ReadMath&quot; &quot;ReceTrai&quot; &quot;Stud&quot; ## [6] &quot;HighComp&quot; &quot;EarlLeav&quot; &quot;ReceGrad&quot; &quot;ActiRate&quot; &quot;ActiRate_1&quot; ## [11] &quot;LongUnem&quot; &quot;UndePart&quot; &quot;HighEduc&quot; &quot;Isce5-Pr&quot; &quot;QualMism&quot; While the codes could certainly be improved, its certainly better than uninformative numbers. Finally, we can assemble the output into a COIN and begin the construction. ESI &lt;- assemble(dflist[[1]],dflist[[2]],dflist[[3]],) ## ----------------- ## No denominators detected. ## ----------------- ## ----------------- ## Indicator codes cross-checked and OK. ## ----------------- ## Number of indicators = 15 ## Number of units = 28 ## No Year column detected in input data. Assuming you only have one year of data. ## Number of aggregation levels = 3 above indicator level. ## ----------------- ## Aggregation level 1 with 6 aggregate groups: sp.01, sp.02, sp.03, sp.04, sp.05, sp.06 ## Cross-check between metadata and framework = OK. ## Aggregation level 2 with 3 aggregate groups: p.01, p.02, p.03 ## Cross-check between metadata and framework = OK. ## Aggregation level 3 with 1 aggregate groups: Index ## Cross-check between metadata and framework = OK. ## ----------------- 11.2 Selecting data sets and indicators The getIn() function is widely used by many COINr functions. It is used for selecting specific data sets, and returning subsets of indicators. While some of this can be achieved fairly easily with base R, or dplyr::select(), subsetting in a hierarchical context can be more awkward. Thats where getIn() steps in to help. Lets take some examples: 11.2.1 Getting a whole data set Explanation using ASEM data 11.2.2 Getting specific indicators Explanation using ASEM data, also of getting aggregate group data 11.2.3 Getting indicators belonging to an aggregation group Explanation using ASEM data, also multiple groups 11.2.4 Getting aggregate group data at targeted level Explanation using ASEM data 11.2.5 Use with data frames Examples with just data frames 11.3 Rounding data frames The roundDF function is a small helper function for rounding data frames that contain a mix of numeric and non-numeric columns. This is very handy for presenting tables generated by COINr in documents. Full disclosure, I was also involved in the development of the COIN Tool "],["appendix-r-resources.html", "Chapter 12 Appendix: R Resources 12.1 Introduction to R 12.2 Advanced resources", " Chapter 12 Appendix: R Resources One of the great things about R is the sheer number of freely-available resources that are out there. Not just the software and packages, but also online books and materials to learn everything you need to know about pretty much anything. Here are a list of resources for users who (a) are interested in R and want to get started, and (b) are proficient R users but want to learn more. I am focusing here on resources that have really helped me in the work that I have done. Of course there is far more out there and you only have to look. 12.1 Introduction to R If youre just starting out, these are good places to start. R for Data Science is a modern classic that starts from the beginning and leads you into the world of R, from a data science perspective. It uses the tidyverse approach which is developed by R Guru Hadley Wickham. Even advanced users can probably learn something here. https://r4ds.had.co.nz/index.html Swirl is an R package which lets you learn R at the command line. Also very good for beginners. https://swirlstats.com/ 12.2 Advanced resources 12.2.1 Programming If you really want to sharpen your programming skills in R, Hadley Wickham has another book: this one digs around in the roots of R and teaches you all kinds of tricks and quirks. https://adv-r.hadley.nz/ Want to build your own R package? Hadley come to the rescue, again. https://r-pkgs.org/ 12.2.2 Visualisation Plotly is a big R package which generates interactive graphics using Javascript (there are many others, by the way). This book tells you all you need to know about that. https://plotly-r.com/ Shiny is another R package which lets you build interactive web apps based on R code. Its tricky to get your head around at first, but this book really helps. https://mastering-shiny.org/index.html 12.2.3 Other If youre not using GitHub, ask yourself, why not? GitHub is the best way to collaborate and share code, and you can also host documentation and websites. This book is hosted on GitHub, to take a random example. The Happy Git with R Book gives an easy introduction to hooking up R Studio to work seamlessly with Git and Github. https://happygitwithr.com/ You wouldnt think that R would be a good tool for writing books, but actually it turns out that its a pretty good tool for writing books. The Bookdown package lets you build nifty online books with a simple and neat layout. You can include equations and importantly, R code, outputs and HTML widgets, etc. https://bookdown.org/yihui/bookdown/ Finally, you wouldnt think that R would be a good tool for building website, but actually it turns out its a pretty good tool for building websites. OK, yes, if you want to build something really complicated and/or highly customised, then its not the way forward. But for building fairly simple sites and blogs, personal pages etc (especially if you want to stick in some R code), then the Blogdown package gives a great way to do this. And guess what, you can link it to Github and it automatically updates your website when you push any changes from R Studio. And its all free. An example of this is my very humble website which you can find at http://www.bluefoxdata.eu. Whats that you say, if only there were a book to teach me how to do all this? Well youre in luck - here it is. https://bookdown.org/yihui/blogdown/ "],["acknowledgements.html", "Chapter 13 Acknowledgements", " Chapter 13 Acknowledgements COINr, like all R packages, has been built off of the back of many other packages. Some that COINr uses in particular are: Plotly, for beautiful javascript plots ggplot2, for beautiful static plots reactable, for nice interactive tables shiny, for apps Various elements of the tidyverse, particularly dplyr "]]
