[["index.html", "COINr: An R Package for Composite Indicator Development and Analysis Chapter 1 Overview 1.1 Installation 1.2 Whats it for? 1.3 Quick-start guide", " COINr: An R Package for Composite Indicator Development and Analysis William Becker 2021-02-10 Chapter 1 Overview This documentation describes in detail the COINr package, which is an R package for developing and analysing composite indicators. At the moment, the documentation is very incomplete, and this is mostly here as a placeholder. However, this will be updated over time. 1.1 Installation COINr is currently under development, but a very limited very beta version can be installed via Github. First, install the devtools package if you dont already have it, then run: devtools::install_github(&quot;bluefoxr/COINr&quot;) This should directly install the package from Github, without any other steps. You may be asked to update packages. This might not be strictly necessary, so you can also try to skip this step. 1.2 Whats it for? COINr is the first fully-flexible development and analysis environment for composite indicators and scoreboards. It allows: Flexible and fast development of composite indicators with no limits on aggregation levels, numbers of indicators, highly flexible set of methodological choices. In-depth statistical analysis of indicators and results, including multivariate analysis, statistical reweighting, uncertainty and sensitivity analysis, etc. Interactive data exploration and visualisation via Shiny apps which can be hosted online. HTML widgets for incorporation in interactive markdown documents. 1.3 Quick-start guide COINr is highly customisable, but equally allows composite indicator construction in a few commands. Taking the built-in ASEM dataset, we can assemble a composite indicator in a few steps. library(COINr) # assemble basic composite indicator object from input data ASEM &lt;- coin_assemble(IndData = ASEMIndData, IndMeta = ASEMIndMeta, AggMeta = ASEMAggMeta) ## ----------------- ## Indicator codes cross-checked and OK. ## ----------------- ## Number of indicators = 49 ## Number of units = 51 ## Number of reference years of data = 1 ## Years from 2018 to 2018 ## Number of aggregation levels = 3 above indicator level. ## ----------------- ## Aggregation level 1 with 8 aggregate groups: Physical, ConEcFin, Political, Instit, P2P, Environ, Social, SusEcFin ## Cross-check between metadata and framework = OK. ## Aggregation level 2 with 2 aggregate groups: Conn, Sust ## Cross-check between metadata and framework = OK. ## Aggregation level 3 with 1 aggregate groups: Index ## Cross-check between metadata and framework = OK. ## ----------------- # denominate data using specifications in ASEMIndMeta ASEM &lt;- coin_denominate(ASEM) # normalise data ASEM &lt;- coin_normalise(ASEM, dset = &quot;Denominated&quot;) # Aggregate normalised data ASEM &lt;- coin_aggregate(ASEM, dset = &quot;Normalised&quot;) At this point, the dashboard for viewing the results interactively is still under development. Still, we can view a number of things. First, we may want to see the index structure: coin_plotframework(ASEM) This is an interactive HTML widget which can be embedded into HTML documents (such as this page). We can also analyse indicator statistics: library(reactable) library(magrittr) ASEM &lt;- coin_preanalyse(ASEM, dset = &quot;Raw&quot;) ASEM$Analysis$Raw$StatTable %&gt;% reactable::reactable(defaultPageSize = 5, highlight = TRUE, wrap = F) "],["introduction.html", "Chapter 2 Introduction 2.1 How to use COINr", " Chapter 2 Introduction The COINr package is a comprehensive development and analysis environment for composite indicators and scoreboards, featuring a range of tools for building, visualising and analysing. This vignette is a work in progress and will be expanded as the COINr project progresses. 2.1 How to use COINr There are two main ways to use COINr. The first is to use the functions as standalone tools for your own specific use. For example, coin_normalise.R will take a data frame as an input, and normalise the columns according to the options specified in its input, outputting another data frame. The second way is to work inside what Ill call the COINrverse (with tongue firmly in cheek). What this means is that all operations are performed on a single object, the COIN object, which stores all data, all analysis, parameters, and methodological choices made along the way. The COINrverse approach enables the full feature set of COINr, because some functions only work on COIN objects - for example, exporting all results to Excel in one command, or running an uncertainty/sensitivity analysis. Indeed, COINr is built mainly for COINrverse use, but functions have been written with the flexibility to also accommodate independent use where possible. More details on how the COINrverse works can be found in XXX. "],["terminology.html", "Chapter 3 Terminology", " Chapter 3 Terminology Lets clearly define a few terms first to avoid confusion later on. An indicator is a variable which has an observed value for each unit. Indicators might be things like life expectancy, CO2 emissions, number of tertiary graduates, and so on. A unit is one of the entities that you are comparing with indicators. Often, units are countries, but they could also be regions, universities, individuals or even competing policy options (the latter is the realm of multicriteria decision analysis). Together, indicators and units form the main input data frame for COINr (units as rows, and indicators as columns). "],["data-input.html", "Chapter 4 Data Input 4.1 Introduction 4.2 The three inputs 4.3 Putting everything together 4.4 Moving on", " Chapter 4 Data Input 4.1 Introduction Where possible COINr functions can be used as standalone functions, typically on data frames of indicator data, for operations such as normalisation, imputation and so on. The full functionality of COINr is however harnessed by assembling the indicator data, and the structure of the index, into a COIN Object (catchier name pending). The COIN object is a structured list, which neatly stores the various data sets, parameters, analyses and methodological decisions in one place. There are various reasons for doing this: It simplifies operations because functions know where data and parameters are. Therefore, COINr operations typically follow a syntax of the form COINobj &lt;- COINr_function(COINobj, &lt;methodological settings&gt;), updating the COIN object with new results and data sets generated by the function. This avoids having to repeatedly specify indicator names, structure, etc, as separate arguments. It keeps things organised and avoids a workspace of dozens of variables. It keeps a record of methodological decisions - this allows results to be easily regenerated following what if experiments, such as removing or changing indicators etc (see Section on adjustments and reruns TO ADD). The logic of doing this will become clearer as you build your index. If you only want to use the COINr functions on data frames, you can probably skip this chapter. 4.2 The three inputs To build a COIN object, three ingredients (data frames) are needed to begin with. In short, they are the indicator data, the indicator metadata, and the aggregation metadata. Here, each will be explained separately. Inputting the data in the first place is where you will do most of the work, because you have to get your data in a format that COINr understands. But once you have got your data assembled, COINr should do most of the hard work, so hang in there! 4.2.1 Indicator data The indicator data is a data frame which, shockingly, specifies the data for the indicators. However, it can do more than that, and also some rules have to be followed. The easiest way to explain is to start with an example. library(COINr) head(ASEMIndData) COINr comes prepackaged with some example data - here we are looking at indicator data from the ASEM Sustainable Connectivity Portal, which has an indicator data set covering 51 Asian and European countries. The first thing to notice is that each row is an observation (here, a country), and each column is a variable (mostly indicators, but also other things). Look at the structure of the data frame, working from left to right: UnitName [required] gives the name of each unit. Here, units are countries, so these are the names of each country. UnitCode [required] is a unique code assigned to each unit (country). This is very important, and is the main reference inside COINr for units. If your units are countries, I recommend using ISO Alpha-3 codes, because these are recognised by COINr for generating maps. It also makes data processing generally easier. Group_* [optional] Any column name that starts with Group_ is recognised as a group column rather than an indicator. You dont have to have any groups, but some COINr functions support specific operations on groups (e.g. imputation within group, and future updates plan to expand this capacity). You can have as many group columns as you want. Year [optional] gives the reference year of the data. This allows you to have multiple years of data, for example, you can have a value for a given country for 2018, and another value for the same country for 2019, and so on. Like groups, this feature is not yet fully developed in COINr. Den_*[optional] Any column names that begin with Den_* are recognised as denominators, i.e. indicators that are used to scale other indicators. Any remaining columns that do not use the names in this list are recognised as indicators. You will notice that all column (variable/indicator) names use short codes. This is to keep things concise in tables, rough plots etc. The full names of indicators, and other details, are also specified in the indicator metadata table - see the next section. Some important rules and tips to keep in mind are: The following columns are required. All other columns are optional: UnitCode UnitName At least one indicator column Columns dont have to be in any particular order, columns are identified by names rather than positions. You can have as many indicators and units as you like. Indicator codes and unit codes must have unique names. You cant use the same code twice otherwise bad things will happen. Avoid any accented characters or basically any characters outside of English - this can sometimes cause trouble with encoding. Column names are case-sensitive. Most things in COINr are built to have a degree of flexibility where possible, but column names need to be written exactly as they appear here for COINr to recognise them., 4.2.2 Indicator metadata The second data frame you need to input specifies the metadata of each indicator. This serves two purposes: first, to give details about each indicator, such as its name, its units and so on; and second, to specify the structure of the index. Heres what this looks like, for our example ASEM data set: head(ASEMIndMeta) Notice that now, the table is flipped on its side (transposed), and each row is an indicator, and the columns specify other things. This is to keep the data in a tidy format. Lets go through the columns one by one. IndName [required] This is the full name of the indicator, which will be used in display plots. IndCode[required] A reference code for each indicator. These must be the same codes as specified in the indicator metadata. The codes must also be unique. Direction [required] The direction of each indicator - this takes values of either 1 or -1 for each indicator. A value of 1 means that higher values of the indicator correspond to higher values of the index, whereas -1 means the opposite. IndWeight [required] The initial weights assigned to each indicator. Weights are relative and do not need to sum to one, so you can simply put all 1s here if you dont know what else to put (the values can be adjusted later). Denominator [required??] These should be the indicator codes of one of the denominator variables for each indicator to be denominated. E.g. here Den_Pop specifies that the indicator should be denominated by the Den_Pop indicators (population, in this case). For any indicators that do not need denominating, just set NA. Denominators can also be specified later, so if you want you can leave this column out. IndUnit [optional] The units of the indicator. This helps for keeping track of what the numbers actually mean, and can be used in plots. Agg* [required] Any column name that begins with Agg is recognised as a column specifying the aggregation group, and therefore the structure of the index. Aggregation columns should be in the order of the aggregation, but otherwise can have arbitrary names. Lets look at the aggregation columns in a bit more detail. Each column represents a separate aggregation level, so in the ASEM example here we have three aggregation levels - the pillars, the two sub-indexes, and the overall index. The entry of each column specifies which group each indicator falls in. So, the first column Agg1 specifies the pillar of each indicator. Again, each aggregation group (pillar, sub-index or index) is referenced by a unique code. The next column Agg2, gives the sub-index that the indicator belongs to. There is a bit of redundancy here, because obviously indicators in the same pillar must also belong to the same sub-index. Finally, Agg3 specifies that all indicators belong to the index. You can have as many Agg columns as you like, and the names dont have to be Agg1 etc, but could be e.g. Agg_Pillar, Agg_SubIndex, etc. However, they must begin with Agg, otherwise COINr will not recognise them. And they must appear in the order of the aggregation, i.e. lowest level of aggregation first, then working upwards. 4.2.3 Aggregation metadata The final data input is the aggregation metadata, which is also the simplest. Heres our example for the ASEM data set: head(ASEMAggMeta) This data frame simply consists of three columns for each aggregation level: *Code [required] The aggregation group codes. This column must end with Code, and the codes must match the codes in the corresponding column in the indicator metadata aggregation columns. *Name [required] The aggregation group names. This column must end with Name. *Weight [required] The aggregation group weights. This column must end with Weight. Again, these weights can be changed later on. Columns must appear in the order of the aggregation groups. 4.3 Putting everything together Having got all your data in the correct format, you can finally build it into a COIN object. From here, things start to get a bit easier. The function to build the COIN object is called coin_assemble(). This function takes the three data frames mentioned and converts them into a so-called COIN Object, which is a hierarchical list that is structured in a way that is recognised by all COINr functions. Lets run coin_assemble() using the built-in data sets to show how it works. ASEM &lt;- coin_assemble(IndData = ASEMIndData, IndMeta = ASEMIndMeta, AggMeta = ASEMAggMeta) The three inputs here are as follows: IndData which is the indicator data IndMeta which is the indicator metadata AggMeta which is the aggregation metadata And this outputs a COIN Object which you can name as you want (here we have called it ASEM). There are two further arguments to coin_assemble() which are not used here, and they are: include - this is a character vector of indicator codes (i.e. codes that are found in IndData$IndCode) which specifies which indicators to include out of the IndData and IndMeta inputs. By default, all indicators are included, but this gives the option to only include certain indicators, if for example, you have several alternative data sources. exclude- this an analogous character vector of indicator codes, but specifying which indicators to exclude, if any. Again, by default, nothing is excluded. This may be easier to specify when creating a subset of indicators. The structure of the list is as follows. First, it is divided into five main sub-lists, which I am going to call folders: Input is the input data, and has the following entries: IndData The indicator data, after any exclusion of indicators IndMeta The indicator metadata, after any exclusion of indicators AggMeta The aggregation metadata, after any exclusion of indicators Original A list containing the original, unaltered inputs to coin_assemble() Data is where the indicator data sets are stored. As you go through the construction, this will populated with more data sets, e.g. imputed data, treated data, aggregated data, and so on. On first assembly you will only see Raw present here. Parameters stores some useful parameters that are used by COINr functions, and may be of general interest, such as the indicator codes, unit codes, weights, and so on. Analysis is where analysis of the indicator data will be stored, including missing data analysis, indicator summary statistics, principal component analysis and so on. Method keeps a record of the methodological decisions made when constructing the composite indicator, for example the normalisation method and parameters, data treatment specifications, and so on. Apart from keeping a record of the construction, this also allows the entire results to be regenerated using the information stored in the COIN Object, this will be explained better in Chapter XXX. The logic of the COIN object is that COINr functions can take all the data and parameters that they need from it, and you only have to specify some particular parameters of the function. Then, outputs, such as new data sets, are returned back to the COIN object, which is added to and expanded as the analysis progresses. Apart from building the COIN Object, coin_assemble() does a few other things: It checks that indicator codes are consistent between indicator data and indicator metadata It checks that required columns, such as indicator codes, are presenr It returns some basic information about the data that was input, such as the number of indicators, the number of units, the number of aggregation levels and the groups in each level. This is done so you can check what you have entered, and that it agrees with your expectations. 4.4 Moving on Now that you have a COIN Object, you can start using all the other functions in COINr to their full potential. Most functions will still work on standalone data frames, so you dont need to work with COIN objects if you prefer not to. "],["initial-visualisation.html", "Chapter 5 Initial visualisation 5.1 Structure 5.2 Distribution plotting", " Chapter 5 Initial visualisation 5.1 Structure lll 5.2 Distribution plotting "],["imputation.html", "Chapter 6 Imputation 6.1 By indicators 6.2 By units", " Chapter 6 Imputation Imputation is the process of estimating missing data points. This can be done in any number of ways, and as usual, the best way depends on the problem. 6.1 By indicators Column-wise imputation means 6.2 By units A similar but alternative approach is to use values of other units to estimate the missing point. Typically, this could involve the sample mean or median of the indicator. Heres some data from the ASEM data set regarding the average connection speed of each country. Towards the end there are some missing values, so lets view the last few rows: library(COINr) Ind1 &lt;- data.frame(Country = ASEMIndData$UnitName, ConSpeed = ASEMIndData$ConSpeed) Ind1[40:nrow(Ind1),] ## Country ConSpeed ## 40 Korea 28.6 ## 41 Lao PDR NA ## 42 Malaysia 8.9 ## 43 Mongolia NA ## 44 Myanmar NA ## 45 New Zealand 14.7 ## 46 Pakistan NA ## 47 Philippines 5.5 ## 48 Russian Federation 11.8 ## 49 Singapore 20.3 ## 50 Thailand 16.0 ## 51 Vietnam 9.5 Using our simple imputation method, we just replace the NA values with the sample mean. Ind1$ConSpeed &lt;- replace(Ind1$ConSpeed, is.na(Ind1$ConSpeed), mean(Ind1$ConSpeed, na.rm = T)) Ind1[40:nrow(Ind1),] ## Country ConSpeed ## 40 Korea 28.60000 ## 41 Lao PDR 14.28605 ## 42 Malaysia 8.90000 ## 43 Mongolia 14.28605 ## 44 Myanmar 14.28605 ## 45 New Zealand 14.70000 ## 46 Pakistan 14.28605 ## 47 Philippines 5.50000 ## 48 Russian Federation 11.80000 ## 49 Singapore 20.30000 ## 50 Thailand 16.00000 ## 51 Vietnam 9.50000 "],["denomination.html", "Chapter 7 Denomination 7.1 Example one 7.2 Example two", " Chapter 7 Denomination Some significant applications are demonstrated in this chapter. 7.1 Example one 7.2 Example two "],["normalisation.html", "Chapter 8 Normalisation", " Chapter 8 Normalisation Some stuff. "],["aggregation.html", "Chapter 9 Aggregation", " Chapter 9 Aggregation Stuff. "],["weighting.html", "Chapter 10 Weighting 10.1 Approaches to weighting 10.2 Interactive re-weighting with ReW8R 10.3 Automatic re-weighting 10.4 Manual re-weighting", " Chapter 10 Weighting Strictly speaking, weighting comes before aggregation. However, in order to understand the effects of weights, we need to aggregate the index first. Weighting in composite indicators is a thorny issue, which attracts considerable attention and is often one of the main focuses of critics. 10.1 Approaches to weighting Outline of some key approaches 10.2 Interactive re-weighting with ReW8R A description 10.3 Automatic re-weighting The weight optimisation algorithm 10.4 Manual re-weighting Further options for weighting. "],["helper-functions.html", "Chapter 11 Helper functions 11.1 Getting a whole data set 11.2 Getting specific indicators 11.3 Getting indicators belonging to an aggregation group 11.4 Getting aggregate group data at targeted level 11.5 Use with data frames", " Chapter 11 Helper functions The getIn() function is widely used by many COINr functions. It is used for selecting specific data sets, and returning subsets of indicators. While some of this can be achieved fairly easily with base R, or dplyr::select(), subsetting in a hierarchical context can be more awkward. Thats where getIn() steps in to help. Lets take some examples: 11.1 Getting a whole data set Explanation using ASEM data 11.2 Getting specific indicators Explanation using ASEM data, also of getting aggregate group data 11.3 Getting indicators belonging to an aggregation group Explanation using ASEM data, also multiple groups 11.4 Getting aggregate group data at targeted level Explanation using ASEM data 11.5 Use with data frames Examples with just data frames "],["appendix-r-resources.html", "Chapter 12 Appendix: R Resources 12.1 Introduction to R 12.2 Advanced resources", " Chapter 12 Appendix: R Resources One of the great things about R is the sheer number of freely-available resources that are out there. Not just the software and packages, but also online books and materials to learn everything you need to know about pretty much anything. Here are a list of resources for users who (a) are interested in R and want to get started, and (b) are proficient R users but want to learn more. I am focusing here on resources that have really helped me in the work that I have done. Of course there is far more out there and you only have to look. 12.1 Introduction to R If youre just starting out, these are good places to start. R for Data Science is a modern classic that starts from the beginning and leads you into the world of R, from a data science perspective. It uses the tidyverse approach which is developed by R Guru Hadley Wickham. Even advanced users can probably learn something here. https://r4ds.had.co.nz/index.html Swirl is an R package which lets you learn R at the command line. Also very good for beginners. https://swirlstats.com/ 12.2 Advanced resources 12.2.1 Programming If you really want to sharpen your programming skills in R, Hadley Wickham has another book: this one digs around in the roots of R and teaches you all kinds of tricks and quirks. https://adv-r.hadley.nz/ Want to build your own R package? Hadley come to the rescue, again. https://r-pkgs.org/ 12.2.2 Visualisation Plotly is a big R package which generates interactive graphics using Javascript (there are many others, by the way). This book tells you all you need to know about that. https://plotly-r.com/ Shiny is another R package which lets you build interactive web apps based on R code. Its tricky to get your head around at first, but this book really helps. https://mastering-shiny.org/index.html 12.2.3 Other If youre not using GitHub, ask yourself, why not? GitHub is the best way to collaborate and share code, and you can also host documentation and websites. This book is hosted on GitHub, to take a random example. The Happy Git with R Book gives an easy introduction to hooking up R Studio to work seamlessly with Git and Github. https://happygitwithr.com/ You wouldnt think that R would be a good tool for writing books, but actually it turns out that its a pretty good tool for writing books. The Bookdown package lets you build nifty online books with a simple and neat layout. You can include equations and importantly, R code, outputs and HTML widgets, etc. https://bookdown.org/yihui/bookdown/ Finally, you wouldnt think that R would be a good tool for building website, but actually it turns out its a pretty good tool for building websites. OK, yes, if you want to build something really complicated and/or highly customised, then its not the way forward. But for building fairly simple sites and blogs, personal pages etc (especially if you want to stick in some R code), then the Blogdown package gives a great way to do this. And guess what, you can link it to Github and it automatically updates your website when you push any changes from R Studio. And its all free. An example of this is my very humble website which you can find at http://www.bluefoxdata.eu. Whats that you say, if only there were a book to teach me how to do all this? Well youre in luck - here it is. https://bookdown.org/yihui/blogdown/ "]]
